<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Ensure proper scaling on mobile -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- PWA manifest -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#333">
  <title>Ballz Retro</title>
  <!-- Load a retro pixelated font -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    /* Basic reset and centering */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #222;
      font-family: 'Press Start 2P', cursive;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* Game container fills the viewport */
    #game-container {
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* Fixed game area at 360x640 (portrait), scales responsively */
    #game-area {
      position: relative;
      width: 360px;
      height: 640px;
      max-width: 100%;
      max-height: 100%;
      background: #333;
      border: 4px solid #fff;
      image-rendering: pixelated;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    /* Overlays covering the game area */
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 3;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      cursor: pointer;
    }
    /* Menu overlay */
    #menuScreen {
      flex-direction: column;
      font-size: 20px;
    }
    #menuScreen h1 {
      margin-bottom: 30px;
    }
    .menu-button {
      background: #000;
      color: #fff;
      border: 2px solid #fff;
      padding: 10px 20px;
      margin: 10px;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      image-rendering: pixelated;
    }
    .menu-button:active {
      background: #555;
    }
    /* Start and Game Over overlays */
    #startScreen, #gameOverScreen {
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="game-area">
      <canvas id="gameCanvas" width="360" height="640"></canvas>
      <!-- Menu overlay (shown at launch) -->
      <div id="menuScreen" class="overlay">
        <div id="menuContent">
          <h1>BALLZ RETRO</h1>
          <div class="menu-button" onclick="selectMode()">Play</div>
        </div>
      </div>
      <!-- Start overlay (shown after mode selection) -->
      <div id="startScreen" class="overlay" style="display:none;" onclick="startGame()">
        Click anywhere to start the game
      </div>
      <!-- Game Over overlay -->
      <div id="gameOverScreen" class="overlay" style="display:none;" onclick="restartGame()">
        Game Over!<br>Click to restart.
      </div>
    </div>
  </div>

  <script>
    // -------------------------------------------------
    // Service Worker Registration (for PWA Installability)
    // -------------------------------------------------
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then(reg => console.log("Service Worker registered with scope:", reg.scope))
          .catch(err => console.log("SW registration failed:", err));
      });
    }

    // -------------------------------------------------
    // External Asset Loading with Fallback
    // -------------------------------------------------
    let ballImg = new Image();
    ballImg.src = "assets/ball.png";
    ballImg.onerror = () => { ballImg = null; };

    let blockImg = new Image();
    blockImg.src = "assets/block.png";
    blockImg.onerror = () => { blockImg = null; };

    let backgroundImg = new Image();
    backgroundImg.src = "assets/background.png";
    backgroundImg.onerror = () => { backgroundImg = null; };

    // -------------------------------------------------
    // Global Game Variables & Settings
    // -------------------------------------------------
    const GAME_WIDTH = 360;
    const GAME_HEIGHT = 640;
    // Grid settings (for Scroll Play)
    const columns = 7;
    const gap = 4;
    const topMargin = 10;
    const leftMargin = 0;
    const blockSize = Math.floor((GAME_WIDTH - (columns - 1) * gap) / columns);
    const cellHeight = blockSize + gap;
    // Blocks now drop exactly one grid unit per round.
    let globalDropOffset = 0;
    const normalBlockColors = ["#FF5555", "#FFAA00", "#55FF55", "#55AAFF", "#AA55FF"];
    
    // Game state variables
    let totalBalls = 1;           // Total balls the player currently has.
    let displayBalls = totalBalls; // Visual counter that counts down when balls are launched.
    let activeBalls = [];         // Balls in flight.
    let ballsToLaunch = 0;
    let launchTimer = 0;
    const launchDelay = 5;
    let turnShooting = false;
    let launchVx = 0, launchVy = 0;
    let currentLevel = 1;
    let gameStarted = false;
    // Dynamic shooter origin: for round one, shooter.x is center; later, it updates from last ball landing.
    let lastBallX = GAME_WIDTH / 2;
    
    const shooter = { x: GAME_WIDTH / 2, y: GAME_HEIGHT - 30, radius: 8 };
    const aim = { x: shooter.x, y: shooter.y - 100 };

    // -------------------------------------------------
    // Data for Blocks (Scroll Play Mode)
    // -------------------------------------------------
    // In each grid cell, there is a 45% chance to create a block.
    // Of those, 20% are “clock” blocks that are drawn as circles (and give an extra ball when broken) and do not bounce the ball.
    let blocks = [];
    function loadInitialBlocks() {
      blocks = [];
      for (let col = 0; col < columns; col++) {
        if (Math.random() < 0.45) {
          let baseHP = Math.floor(Math.random() * 5) + 1;
          baseHP += Math.floor(currentLevel / 2);
          // Use a reduced scaling factor: 1 + 0.1*(totalBalls - 1)
          let scalingFactor = 1 + (totalBalls - 1) * 0.1;
          let scaledHP = Math.floor(baseHP * scalingFactor);
          let blockType = (Math.random() < 0.20) ? "clock" : "normal";
          let color = (blockType === "clock") ? "#FFFFFF" : normalBlockColors[Math.floor(Math.random() * normalBlockColors.length)];
          blocks.push({ type: blockType, row: 0, col: col, value: scaledHP, color: color });
        }
      }
    }
    function addNewRow() {
      for (let col = 0; col < columns; col++) {
        if (Math.random() < 0.45) {
          let baseHP = Math.floor(Math.random() * 5) + 1;
          baseHP += Math.floor(currentLevel / 2);
          let scalingFactor = 1 + (totalBalls - 1) * 0.1;
          let scaledHP = Math.floor(baseHP * scalingFactor);
          let blockType = (Math.random() < 0.20) ? "clock" : "normal";
          let color = (blockType === "clock") ? "#FFFFFF" : normalBlockColors[Math.floor(Math.random() * normalBlockColors.length)];
          blocks.push({ type: blockType, row: -1, col: col, value: scaledHP, color: color });
        }
      }
    }
    // At the end of each round, drop every block one full grid unit and add a new row.
    function newTurn() {
      // Increment every block's grid row.
      blocks.forEach(block => block.row++);
      globalDropOffset = 0;  // Reset any partial offset.
      // Check for game over: if any block's bottom edge reaches or exceeds GAME_HEIGHT.
      for (let block of blocks) {
        let rect = getBlockRect(block);
        if (rect.y + rect.height >= GAME_HEIGHT) {
          gameOver();
          return;
        }
      }
      addNewRow();
      currentLevel++;
    }

    // -------------------------------------------------
    // Utility & Collision Functions
    // -------------------------------------------------
    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }
    function getBlockRect(block) {
      const x = leftMargin + block.col * (blockSize + gap);
      const y = topMargin + block.row * (blockSize + gap);
      return { x: x, y: y, width: blockSize, height: blockSize };
    }
    // For normal blocks, we use rectangular collision;
    // for clock blocks, we'll use circle–circle collision.
    function circleRectCollision(circle, rect) {
      const closestX = clamp(circle.x, rect.x, rect.x + rect.width);
      const closestY = clamp(circle.y, rect.y, rect.y + rect.height);
      const dx = circle.x - closestX;
      const dy = circle.y - closestY;
      return (dx * dx + dy * dy) < (circle.radius * circle.radius);
    }
    function circleCircleCollision(c1, r1, c2, r2) {
      const dx = c1.x - c2.x;
      const dy = c1.y - c2.y;
      const distSq = dx * dx + dy * dy;
      return distSq < ((r1 + r2) * (r1 + r2));
    }

    // -------------------------------------------------
    // Sound Effect Setup
    // -------------------------------------------------
    const popSound = new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=");
    popSound.onerror = () => {};

    // -------------------------------------------------
    // Ball Launching & Updating
    // -------------------------------------------------
    function updateBalls() {
      if (!gameStarted) return;
      
      if (turnShooting) {
        launchTimer++;
        if (launchTimer >= launchDelay && ballsToLaunch > 0) {
          launchTimer = 0;
          ballsToLaunch--;
          displayBalls--;
          activeBalls.push({ x: shooter.x, y: shooter.y, radius: 5, vx: launchVx, vy: launchVy });
        }
      }
      for (let i = 0; i < activeBalls.length; i++) {
        let b = activeBalls[i];
        b.x += b.vx;
        b.y += b.vy;
        // Bounce off left/right walls.
        if (b.x < b.radius || b.x > GAME_WIDTH - b.radius) {
          b.vx = -b.vx;
          b.x = (b.x < b.radius) ? b.radius : GAME_WIDTH - b.radius;
        }
        // Bounce off the top.
        if (b.y < b.radius) {
          b.vy = -b.vy;
          b.y = b.radius;
        }
        let collided = false;
        let collisionDx = 0, collisionDy = 0;
        // Check collision with each block.
        for (let j = blocks.length - 1; j >= 0; j--) {
          let block = blocks[j];
          if (block.type === "clock") {
            // For clock blocks, treat them as circles.
            let rect = getBlockRect(block);
            let clockCenter = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
            let clockRadius = rect.width * 0.45;  // Slightly smaller than half the block width.
            if (circleCircleCollision({x: b.x, y: b.y}, b.radius, clockCenter, clockRadius)) {
              collided = true;
              block.value--;
              popSound.currentTime = 0;
              popSound.play().catch(() => {});
              if (block.value <= 0) {
                totalBalls++; // Clock blocks now give an extra ball.
                blocks.splice(j, 1);
              }
              // For clock blocks, do not reflect ball velocity.
            }
          } else {
            // Normal blocks: use rectangular collision.
            let rect = getBlockRect(block);
            if (circleRectCollision(b, rect)) {
              collided = true;
              block.value--;
              popSound.currentTime = 0;
              popSound.play().catch(() => {});
              if (block.value <= 0) {
                // Normal blocks no longer award bonus balls.
                blocks.splice(j, 1);
              }
              let blockCenter = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
              collisionDx += (b.x - blockCenter.x);
              collisionDy += (b.y - blockCenter.y);
            }
          }
        }
        // For normal blocks only, if a collision occurred, reflect velocity.
        if (collided) {
          // Only reflect if the collision was with a normal block
          if (collisionDx !== 0 || collisionDy !== 0) {
            if (Math.abs(collisionDx) > Math.abs(collisionDy))
              b.vx = -b.vx;
            else
              b.vy = -b.vy;
          }
        }
      }
      // Remove balls that have reached the bottom.
      activeBalls = activeBalls.filter(b => {
        if (b.y > GAME_HEIGHT - b.radius) {
          lastBallX = b.x;
          return false;
        }
        return true;
      });
      
      if (turnShooting && activeBalls.length === 0 && ballsToLaunch === 0) {
        turnShooting = false;
        displayBalls = totalBalls;
        // Update shooter position for the next round.
        shooter.x = lastBallX;
        newTurn();
      }
    }
    
    // -------------------------------------------------
    // Drawing Functions
    // -------------------------------------------------
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    function draw() {
      ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
      if (backgroundImg) {
        ctx.drawImage(backgroundImg, 0, 0, GAME_WIDTH, GAME_HEIGHT);
      }
      // Draw shooter (only when not shooting)
      if (!turnShooting) {
        if (ballImg) {
          ctx.drawImage(ballImg, shooter.x - shooter.radius, shooter.y - shooter.radius, shooter.radius * 2, shooter.radius * 2);
        } else {
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.arc(shooter.x, shooter.y, shooter.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      // Draw active balls.
      activeBalls.forEach(b => {
        if (ballImg) {
          ctx.drawImage(ballImg, b.x - b.radius, b.y - b.radius, b.radius * 2, b.radius * 2);
        } else {
          ctx.fillStyle = "#ff0";
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      // Draw aim line if not shooting.
      if (!turnShooting) {
        ctx.strokeStyle = "#0f0";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(shooter.x, shooter.y);
        ctx.lineTo(aim.x, aim.y);
        ctx.stroke();
      }
      // Draw blocks.
      blocks.forEach(block => {
        let rect = getBlockRect(block);
        if (block.type === "clock") {
          // Draw as a circle.
          ctx.fillStyle = "#FFFFFF";
          ctx.beginPath();
          ctx.arc(rect.x + rect.width/2, rect.y + rect.height/2, rect.width/2, 0, Math.PI * 2);
          ctx.fill();
          // Optionally, you can stroke it.
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(rect.x + rect.width/2, rect.y + rect.height/2, rect.width/2 - 4, 0, Math.PI*2);
          ctx.stroke();
        } else {
          // Normal block.
          if (blockImg) {
            ctx.drawImage(blockImg, rect.x, rect.y, rect.width, rect.height);
          } else {
            ctx.fillStyle = block.color;
            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 2;
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
          }
        }
        // Draw hit-point number centered.
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(block.value, rect.x + rect.width/2, rect.y + rect.height/2);
      });
      // Draw UI: Ball counter at bottom-left; Level at bottom-right.
      ctx.font = "16px 'Press Start 2P', cursive";
      ctx.textAlign = "left";
      ctx.fillStyle = "#fff";
      ctx.fillText("Balls: " + (turnShooting ? displayBalls : totalBalls), 10, GAME_HEIGHT - 10);
      ctx.textAlign = "right";
      ctx.fillText("lv " + currentLevel, GAME_WIDTH - 10, GAME_HEIGHT - 10);
    }
    function gameLoop() {
      updateBalls();
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    // -------------------------------------------------
    // Overlays: Menu, Start, and Game Over
    // -------------------------------------------------
    function selectMode() {
      // Only one mode remains: scroll play.
      gameMode = "scroll";
      document.getElementById("menuScreen").style.display = "none";
      document.getElementById("startScreen").style.display = "flex";
      loadInitialBlocks();
    }
    function startGame() {
      gameStarted = true;
      document.getElementById("startScreen").style.display = "none";
    }
    function gameOver(win = false) {
      gameStarted = false;
      let msg = win ? "You Win!<br>Click to restart." : "Game Over!<br>Click to restart.";
      document.getElementById("gameOverScreen").innerHTML = msg;
      document.getElementById("gameOverScreen").style.display = "flex";
    }
    function restartGame() {
      totalBalls = 1;
      currentLevel = 1;
      globalDropOffset = 0;
      activeBalls = [];
      turnShooting = false;
      displayBalls = totalBalls;
      loadInitialBlocks();
      document.getElementById("gameOverScreen").style.display = "none";
      gameStarted = true;
    }
    
    // -------------------------------------------------
    // Input Handling & Minimum Launch Angle Enforcement
    // -------------------------------------------------
    function getPointerPos(evt) {
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;
      if (evt.touches && evt.touches.length > 0) {
        clientX = evt.touches[0].clientX;
        clientY = evt.touches[0].clientY;
      } else {
        clientX = evt.clientX;
        clientY = evt.clientY;
      }
      return { x: clientX - rect.left, y: clientY - rect.top };
    }
    canvas.addEventListener("mousedown", (evt) => {
      if (!gameStarted) return;
      const pos = getPointerPos(evt);
      aim.x = pos.x;
      aim.y = pos.y;
    });
    canvas.addEventListener("mousemove", (evt) => {
      if (!gameStarted) return;
      const pos = getPointerPos(evt);
      aim.x = pos.x;
      aim.y = pos.y;
    });
    canvas.addEventListener("mouseup", (evt) => {
      if (!gameStarted || turnShooting) return;
      const pos = getPointerPos(evt);
      aim.x = pos.x;
      aim.y = pos.y;
      let dx = aim.x - shooter.x;
      let dy = aim.y - shooter.y;
      // Enforce minimum upward angle: about 4° above horizontal.
      const minRatio = Math.tan(4 * Math.PI / 180);
      if (Math.abs(dy) < Math.abs(dx) * minRatio) {
        dy = -Math.abs(dx) * minRatio;
      }
      const mag = Math.sqrt(dx * dx + dy * dy);
      if (mag === 0) return;
      // Reduced ball speed multiplier: 6.
      launchVx = (dx / mag) * 6;
      launchVy = (dy / mag) * 6;
      turnShooting = true;
      ballsToLaunch = totalBalls;
      activeBalls = [];
      launchTimer = 0;
      displayBalls = totalBalls;
    });
    canvas.addEventListener("touchstart", (evt) => {
      evt.preventDefault();
      if (!gameStarted) return;
      const pos = getPointerPos(evt);
      aim.x = pos.x;
      aim.y = pos.y;
    }, { passive: false });
    canvas.addEventListener("touchmove", (evt) => {
      evt.preventDefault();
      if (!gameStarted) return;
      const pos = getPointerPos(evt);
      aim.x = pos.x;
      aim.y = pos.y;
    }, { passive: false });
    canvas.addEventListener("touchend", (evt) => {
      evt.preventDefault();
      if (!gameStarted || turnShooting) return;
      let dx = aim.x - shooter.x;
      let dy = aim.y - shooter.y;
      const minRatio = Math.tan(4 * Math.PI / 180);
      if (Math.abs(dy) < Math.abs(dx) * minRatio) {
        dy = -Math.abs(dx) * minRatio;
      }
      const mag = Math.sqrt(dx * dx + dy * dy);
      if (mag === 0) return;
      launchVx = (dx / mag) * 6;
      launchVy = (dy / mag) * 6;
      turnShooting = true;
      ballsToLaunch = totalBalls;
      activeBalls = [];
      launchTimer = 0;
      displayBalls = totalBalls;
    }, { passive: false });
    
    // -------------------------------------------------
    // Start the Game Loop
    // -------------------------------------------------
    // Start the loop immediately so that overlays are drawn.
    gameLoop();
  </script>
</body>
</html>
