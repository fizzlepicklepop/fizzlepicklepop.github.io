<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gyro Maze: Vibrant</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #111; touch-action: none; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; outline: none; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); color: #fff; display: flex;
            justify-content: center; align-items: center; flex-direction: column;
            z-index: 10; text-align: center; transition: opacity 0.3s;
            backdrop-filter: blur(5px);
        }

        #rotate-message {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: white; z-index: 20;
            flex-direction: column; justify-content: center; align-items: center; text-align: center;
        }

        h1 { margin: 0 0 10px 0; font-size: 3rem; color: #ff0055; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 20px #ff0055; }
        p { color: #aaa; font-size: 1.2rem; margin-bottom: 30px; font-weight: 500; }
        .stats { font-size: 1.5rem; color: #fff; margin-bottom: 20px; font-weight: bold; }
        
        button {
            padding: 20px 60px; font-size: 1.5rem; background: #ff0055;
            border: none; border-radius: 50px; cursor: pointer; color: #fff; font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button:active { transform: scale(0.95); box-shadow: 0 0 10px rgba(255, 0, 85, 0.6); }

        @media screen and (orientation: portrait) {
            #rotate-message { display: flex; }
            #overlay, canvas { display: none; }
        }
    </style>
</head>
<body>

<div id="rotate-message">
    <h1>Please Rotate</h1>
    <p>Landscape Mode Required</p>
    <div style="font-size: 3rem;">↻</div>
</div>

<div id="overlay">
    <h1 id="titleText">Gyro Maze</h1>
    <p id="subText">Tilt to Roll • Sound On</p>
    <div id="stats" class="stats"></div>
    <button id="startBtn">PLAY</button>
</div>

<script>
    // --- VARIABLES ---
    let width, height, cellSize;
    let COLS, ROWS;
    let maze = [];
    
    // Physics
    let ball = { x: 0, y: 0, r: 0, vx: 0, vy: 0 };
    let goal = { x: 0, y: 0 };
    let startTime = 0;
    let isPlaying = false;
    let tiltX = 0, tiltY = 0; 
    let visualTiltX = 0, visualTiltY = 0; 
    let keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
    let audioCtx = null;

    // Three.js
    let scene, camera, renderer;
    let worldContainer; 
    let ballMesh, goalMesh, floorMesh;
    let wallsGroup; 
    let lightDir, lightAmbient;

    // --- PROCEDURAL TEXTURES ---
    
    function createStripedBallTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 256; 
        const ctx = canvas.getContext('2d');
        
        // 1. Base White
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0,0,512,256);
        
        // 2. Bright Red Stripes
        ctx.fillStyle = '#ff0022'; // Brighter red
        
        // Draw 4 Stripes for high visibility
        const stripeHeight = 25;
        const positions = [50, 100, 150, 200];
        
        positions.forEach(y => {
            ctx.fillRect(0, y, 512, stripeHeight);
        });

        // Poles
        ctx.fillRect(0, 0, 512, 15); 
        ctx.fillRect(0, 241, 512, 15); 

        const tex = new THREE.CanvasTexture(canvas);
        return tex;
    }

    function createVibrantFloorTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');

        // --- PALETTES ---
        const palettes = [
            { bg: '#E0F7FA', accent: '#00BCD4' }, // Cyan
            { bg: '#F3E5F5', accent: '#E040FB' }, // Purple
            { bg: '#E8F5E9', accent: '#00E676' }, // Neon Green
            { bg: '#FFF3E0', accent: '#FF9100' }, // Orange
            { bg: '#212121', accent: '#FFEB3B' }, // Dark/Yellow
            { bg: '#FFEBEE', accent: '#FF1744' }  // Red/Pink
        ];
        
        const theme = palettes[Math.floor(Math.random() * palettes.length)];
        const patternType = Math.floor(Math.random() * 3); // 0=Grid, 1=Dots, 2=Checkers

        // Fill Background
        ctx.fillStyle = theme.bg;
        ctx.fillRect(0,0,512,512);

        if (patternType === 0) {
            // GRID MOTIF
            ctx.strokeStyle = theme.accent;
            ctx.lineWidth = 4;
            ctx.globalAlpha = 0.2;
            const step = 64;
            for(let i=0; i<=512; i+=step) {
                ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,512); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(512,i); ctx.stroke();
            }
        } 
        else if (patternType === 1) {
            // POLKA DOT MOTIF
            ctx.fillStyle = theme.accent;
            ctx.globalAlpha = 0.2;
            const step = 64;
            for(let x=32; x<512; x+=step){
                for(let y=32; y<512; y+=step){
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI*2);
                    ctx.fill();
                }
            }
        }
        else if (patternType === 2) {
            // CHECKERBOARD MOTIF
            ctx.fillStyle = theme.accent;
            ctx.globalAlpha = 0.1;
            const step = 128;
            for(let x=0; x<512; x+=step){
                for(let y=0; y<512; y+=step){
                    if ((x+y)%256 === 0) ctx.fillRect(x,y,step,step);
                }
            }
        }

        // Add random "Confetti" for vibrancy
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = theme.accent;
        for(let i=0; i<15; i++){
            const s = Math.random() * 40 + 10;
            const x = Math.random() * 512;
            const y = Math.random() * 512;
            ctx.fillRect(x, y, s, s);
        }

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        // Increase texture repeat for higher density
        tex.repeat.set(10, 10); 
        return tex;
    }

    // --- SETUP ---
    if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');

    document.getElementById('startBtn').addEventListener('click', async () => {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();

        if (!renderer) {
            if (!initThreeJS()) { alert("WebGL failed."); return; }
        }

        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const response = await DeviceOrientationEvent.requestPermission();
                if (response === 'granted') window.addEventListener('deviceorientation', handleOrientation);
            } catch (e) { console.error(e); }
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
        }
        
        startGame();
    });

    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    
    window.addEventListener('resize', () => { 
        resize();
        if (camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(isPlaying) repositionCamera();
        }
    });

    // --- THREE.JS INIT ---
    function initThreeJS() {
        if (typeof THREE === 'undefined') return false;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 5000);
        
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        lightAmbient = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(lightAmbient);

        lightDir = new THREE.DirectionalLight(0xffffff, 0.6);
        lightDir.position.set(50, 200, 100);
        lightDir.castShadow = true;
        lightDir.shadow.mapSize.width = 2048;
        lightDir.shadow.mapSize.height = 2048;
        lightDir.shadow.camera.left = -1000;
        lightDir.shadow.camera.right = 1000;
        lightDir.shadow.camera.top = 1000;
        lightDir.shadow.camera.bottom = -1000;
        scene.add(lightDir);

        worldContainer = new THREE.Group();
        scene.add(worldContainer);

        wallsGroup = new THREE.Group();
        worldContainer.add(wallsGroup);

        // Ball
        const ballGeo = new THREE.SphereGeometry(1, 32, 32);
        const ballTex = createStripedBallTexture();
        const ballMat = new THREE.MeshStandardMaterial({ map: ballTex, roughness: 0.2, metalness: 0.1 });
        ballMesh = new THREE.Mesh(ballGeo, ballMat);
        ballMesh.castShadow = true;
        worldContainer.add(ballMesh);

        // Goal
        const goalGeo = new THREE.BoxGeometry(1, 0.2, 1);
        const goalMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00aa00, emissiveIntensity: 0.5 });
        goalMesh = new THREE.Mesh(goalGeo, goalMat);
        worldContainer.add(goalMesh);

        // Floor
        const floorGeo = new THREE.PlaneGeometry(5000, 5000);
        const floorTex = createVibrantFloorTexture();
        const floorMat = new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.8 });
        floorMesh = new THREE.Mesh(floorGeo, floorMat);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.y = -0.1;
        floorMesh.receiveShadow = true;
        worldContainer.add(floorMesh);

        return true;
    }

    // --- GAME LOGIC ---

    function startGame() {
        document.getElementById('overlay').style.opacity = '0';
        setTimeout(() => { document.getElementById('overlay').style.display = 'none'; }, 300);
        
        resize(); 
        // NEW: Generate random vibrant floor every level
        const newFloorTex = createVibrantFloorTexture();
        floorMesh.material.map = newFloorTex;
        
        generateMaze(); 
        build3DMaze(); 
        
        ball.r = cellSize * 0.35;
        ballMesh.scale.set(ball.r, ball.r, ball.r);
        
        ball.x = cellSize / 2;
        ball.y = cellSize / 2;
        ball.vx = 0; ball.vy = 0;

        ballMesh.rotation.set(0,0,0);
        visualTiltX = 0; visualTiltY = 0;

        const offsetX = (COLS * cellSize) / 2;
        const offsetY = (ROWS * cellSize) / 2;
        goalMesh.position.set(
            (goal.x * cellSize) + (cellSize/2) - offsetX, 
            0.1, 
            (goal.y * cellSize) + (cellSize/2) - offsetY
        );
        goalMesh.scale.set(cellSize * 0.8, 1, cellSize * 0.8);

        startTime = Date.now();
        isPlaying = true;
        loop();
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        const targetSize = Math.max(width, height) < 800 ? 40 : 65;
        COLS = Math.floor(width / targetSize);
        ROWS = Math.floor(height / targetSize);
        if (COLS < 2) COLS = 2; if (ROWS < 2) ROWS = 2;
        if (COLS % 2 === 0) COLS--; if (ROWS % 2 === 0) ROWS--;
        cellSize = Math.floor(Math.min((width - 20) / COLS, (height - 20) / ROWS));
        if (cellSize < 10) cellSize = 10;
    }

    function generateMaze() {
        maze = [];
        goal = { x: COLS - 1, y: ROWS - 1 };
        for (let y = 0; y < ROWS; y++) {
            let row = [];
            for (let x = 0; x < COLS; x++) row.push({ top: true, right: true, bottom: true, left: true, visited: false });
            maze.push(row);
        }
        let stack = [{x:0, y:0}];
        maze[0][0].visited = true;
        while (stack.length > 0) {
            let cell = stack[stack.length - 1];
            let neighbors = [];
            const dirs = [
                { nx: cell.x, ny: cell.y - 1, wall: 'top', opp: 'bottom' },
                { nx: cell.x + 1, ny: cell.y, wall: 'right', opp: 'left' },
                { nx: cell.x, ny: cell.y + 1, wall: 'bottom', opp: 'top' },
                { nx: cell.x - 1, ny: cell.y, wall: 'left', opp: 'right' }
            ];
            for (let d of dirs) {
                if (d.nx >= 0 && d.nx < COLS && d.ny >= 0 && d.ny < ROWS && !maze[d.ny][d.nx].visited) neighbors.push(d);
            }
            if (neighbors.length > 0) {
                let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                maze[cell.y][cell.x][next.wall] = false;
                maze[next.ny][next.nx][next.opp] = false;
                maze[next.ny][next.nx].visited = true;
                stack.push({ x: next.nx, y: next.ny });
            } else stack.pop();
        }
    }

    function build3DMaze() {
        while(wallsGroup.children.length > 0){ wallsGroup.remove(wallsGroup.children[0]); }

        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 });
        const wallHeight = cellSize * 0.7; 
        const wallThickness = Math.max(3, cellSize * 0.15); 
        const offsetX = (COLS * cellSize) / 2;
        const offsetY = (ROWS * cellSize) / 2;

        const geometryV = new THREE.BoxGeometry(wallThickness, wallHeight, cellSize + wallThickness);
        const geometryH = new THREE.BoxGeometry(cellSize + wallThickness, wallHeight, wallThickness);

        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                let c = maze[y][x];
                let tx = (x * cellSize) - offsetX + (cellSize/2); 
                let ty = (y * cellSize) - offsetY + (cellSize/2);

                if (c.top) createWall(geometryH, tx, ty - cellSize/2, wallMaterial, wallHeight);
                if (c.left) createWall(geometryV, tx - cellSize/2, ty, wallMaterial, wallHeight);
                if (y === ROWS - 1 && c.bottom) createWall(geometryH, tx, ty + cellSize/2, wallMaterial, wallHeight);
                if (x === COLS - 1 && c.right) createWall(geometryV, tx + cellSize/2, ty, wallMaterial, wallHeight);
            }
        }
        repositionCamera();
    }

    function createWall(geo, x, z, mat, h) {
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, h/2, z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        wallsGroup.add(mesh);
    }

    function repositionCamera() {
        const mazeHeight = ROWS * cellSize;
        const fov = camera.fov * (Math.PI / 180);
        // TIGHTER ZOOM: Reduced multiplier from 1.3 to 1.1
        let dist = Math.abs(mazeHeight / (2 * Math.tan(fov / 2))) * 1.1; 
        camera.position.set(0, dist, 0); 
        camera.lookAt(0, 0, 0);
        camera.position.z += dist * 0.1; // Small tilt offset
        camera.lookAt(0,0,0);
    }

    // --- PHYSICS (CCD Enabled) ---
    function handleOrientation(event) {
        const maxTilt = 25;
        let x = event.beta; let y = event.gamma;
        if (y > maxTilt) y = maxTilt; if (y < -maxTilt) y = -maxTilt;
        if (x > maxTilt) x = maxTilt; if (x < -maxTilt) x = -maxTilt;
        tiltX = x / maxTilt; tiltY = -(y / maxTilt);
    }

    function update() {
        if (!isPlaying) return;

        let keyDx = 0, keyDy = 0;
        if (keys.ArrowUp || keys.KeyW) keyDy = -1;
        if (keys.ArrowDown || keys.KeyS) keyDy = 1;
        if (keys.ArrowLeft || keys.KeyA) keyDx = -1;
        if (keys.ArrowRight || keys.KeyD) keyDx = 1;

        let ax = keyDx !== 0 ? keyDx : tiltX;
        let ay = keyDy !== 0 ? keyDy : tiltY;

        let targetVisualX = keyDx !== 0 ? keyDx : tiltX;
        let targetVisualY = keyDy !== 0 ? keyDy : tiltY;

        visualTiltX += (targetVisualX - visualTiltX) * 0.1;
        visualTiltY += (targetVisualY - visualTiltY) * 0.1;

        ball.vx += ax * 0.8;
        ball.vy += ay * 0.8;
        ball.vx *= 0.92; 
        ball.vy *= 0.92;

        // Sub-stepping for collision
        const steps = 8; 
        const subVx = ball.vx / steps;
        const subVy = ball.vy / steps;

        for (let i = 0; i < steps; i++) {
            ball.x += subVx;
            checkCollisionX(); 
            ball.y += subVy;
            checkCollisionY(); 
        }

        let pcx = Math.floor(ball.x / cellSize);
        let pcy = Math.floor(ball.y / cellSize);
        if (pcx === goal.x && pcy === goal.y) winGame();

        const offsetX = (COLS * cellSize) / 2;
        const offsetY = (ROWS * cellSize) / 2;
        
        ballMesh.position.x = ball.x - offsetX;
        ballMesh.position.z = ball.y - offsetY;
        ballMesh.position.y = ball.r;

        ballMesh.rotation.x -= ball.vy * 0.05; 
        ballMesh.rotation.z -= ball.vx * 0.05; 

        const maxTiltRad = 0.25; 
        worldContainer.rotation.x = visualTiltY * maxTiltRad;
        worldContainer.rotation.z = -visualTiltX * maxTiltRad; 
    }

    function winGame() {
        if (!isPlaying) return;
        isPlaying = false;
        playWinSound();
        const endTime = Date.now();
        const duration = ((endTime - startTime) / 1000).toFixed(2);
        const overlay = document.getElementById('overlay');
        document.getElementById('titleText').innerText = "MAZE COMPLETE!";
        document.getElementById('stats').innerText = `Time: ${duration}s`;
        document.getElementById('startBtn').innerText = "NEXT LEVEL";
        overlay.style.display = 'flex';
        setTimeout(() => { overlay.style.opacity = '1'; }, 10);
    }

    function checkCollisionX() {
        if (ball.x - ball.r < 0) { ball.x = ball.r; bounceX(); }
        if (ball.x + ball.r > COLS * cellSize) { ball.x = COLS * cellSize - ball.r; bounceX(); }

        let cx = Math.floor(ball.x / cellSize);
        let cy = Math.floor(ball.y / cellSize);
        cx = Math.max(0, Math.min(COLS-1, cx));
        cy = Math.max(0, Math.min(ROWS-1, cy));
        
        let cell = maze[cy][cx];
        let localX = ball.x % cellSize;

        if (cell.right && localX + ball.r > cellSize) { bounceX(); ball.x = (cx + 1) * cellSize - ball.r - 0.1; }
        if (cell.left && localX - ball.r < 0) { bounceX(); ball.x = cx * cellSize + ball.r + 0.1; }
    }
    
    function bounceX() { if(Math.abs(ball.vx)>0.5) playBump(Math.abs(ball.vx)); ball.vx *= -0.3; }

    function checkCollisionY() {
        if (ball.y - ball.r < 0) { ball.y = ball.r; bounceY(); }
        if (ball.y + ball.r > ROWS * cellSize) { ball.y = ROWS * cellSize - ball.r; bounceY(); }

        let cx = Math.floor(ball.x / cellSize);
        let cy = Math.floor(ball.y / cellSize);
        cx = Math.max(0, Math.min(COLS-1, cx));
        cy = Math.max(0, Math.min(ROWS-1, cy));
        
        let cell = maze[cy][cx];
        let localY = ball.y % cellSize;

        if (cell.bottom && localY + ball.r > cellSize) { bounceY(); ball.y = (cy + 1) * cellSize - ball.r - 0.1; }
        if (cell.top && localY - ball.r < 0) { bounceY(); ball.y = cy * cellSize + ball.r + 0.1; }
    }
    
    function bounceY() { if(Math.abs(ball.vy)>0.5) playBump(Math.abs(ball.vy)); ball.vy *= -0.3; }

    function playBump(force) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(150 + Math.random() * 50, audioCtx.currentTime);
        const vol = Math.min(0.5, force / 20); 
        gain.gain.setValueAtTime(0, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.15);
    }

    function playWinSound() {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(freq, now + (i * 0.1));
            gain.gain.setValueAtTime(0, now + (i * 0.1));
            gain.gain.linearRampToValueAtTime(0.2, now + (i * 0.1) + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, now + (i * 0.1) + 0.4);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now + (i * 0.1));
            osc.stop(now + (i * 0.1) + 0.5);
        });
    }

    function loop() {
        if (!isPlaying) return;
        update();
        renderer.render(scene, camera);
        requestAnimationFrame(loop);
    }
</script>
</body>
</html>