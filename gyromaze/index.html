<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gyro Maze: Bulletproof</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; }
        
        canvas { 
            display: block; 
            position: absolute; 
            top: 0; left: 0; right: 0; bottom: 0; 
            width: 100%; height: 100%; 
            outline: none; 
        }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); color: #fff; display: flex;
            justify-content: center; align-items: center; flex-direction: column;
            z-index: 10; text-align: center; transition: opacity 0.3s;
            backdrop-filter: blur(5px);
        }

        #debug-hud {
            position: absolute; bottom: 10px; left: 0; width: 100%;
            text-align: center; color: #444; font-family: monospace; font-size: 10px;
            pointer-events: none; z-index: 5;
        }

        #rotate-message {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: white; z-index: 20;
            flex-direction: column; justify-content: center; align-items: center; text-align: center;
        }

        h1 { margin: 0 0 10px 0; font-size: 3rem; color: #ff0055; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 20px #ff0055; }
        p { color: #aaa; font-size: 1.2rem; margin-bottom: 30px; font-weight: 500; }
        .stats { font-size: 1.5rem; color: #fff; margin-bottom: 20px; font-weight: bold; }
        
        button {
            padding: 20px 60px; font-size: 1.5rem; background: #ff0055;
            border: none; border-radius: 50px; cursor: pointer; color: #fff; font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button:active { transform: scale(0.95); box-shadow: 0 0 10px rgba(255, 0, 85, 0.6); }

        @media screen and (orientation: portrait) {
            #rotate-message { display: flex; }
            #overlay, canvas { display: none; }
        }
    </style>
</head>
<body>

<div id="rotate-message">
    <h1>Please Rotate</h1>
    <p>Landscape Mode Required</p>
    <div style="font-size: 3rem;">↻</div>
</div>

<div id="debug-hud">System Ready</div>

<div id="overlay">
    <h1 id="titleText">Gyro Maze</h1>
    <p id="subText">Tilt • Keys • Gamepad</p>
    <div id="stats" class="stats"></div>
    <button id="startBtn">PLAY</button>
</div>

<script>
    // --- VARIABLES ---
    let width, height, cellSize;
    let COLS, ROWS;
    let maze = [];
    
    // Physics
    let ball = { x: 0, y: 0, r: 0, vx: 0, vy: 0 };
    let goal = { x: 0, y: 0 };
    let startTime = 0;
    let isPlaying = false;
    let gameEndedTime = 0; 
    let tiltX = 0, tiltY = 0; 
    let visualTiltX = 0, visualTiltY = 0; 
    let keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
    let audioCtx = null;
    let lastBumpTime = 0;
    let wallThicknessVal = 0; 

    // Three.js
    let scene, camera, renderer;
    let worldContainer; 
    let ballMesh, goalMesh, floorMesh;
    let wallsGroup; 
    let lightDir, lightAmbient;
    let currentWallMaterial;

    // --- TEXTURES ---
    function createStripedBallTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 256; 
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,512,256);
        ctx.fillStyle = '#ff0033'; 
        [50, 100, 150, 200].forEach(y => ctx.fillRect(0, y, 512, 25));
        ctx.fillRect(0, 0, 512, 15); ctx.fillRect(0, 241, 512, 15); 
        return new THREE.CanvasTexture(canvas);
    }

    function createVibrantFloorTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        const palettes = [
            { bg: '#E0F7FA', accent: '#00BCD4' }, { bg: '#F3E5F5', accent: '#E040FB' },
            { bg: '#E8F5E9', accent: '#00E676' }, { bg: '#FFF3E0', accent: '#FF9100' },
            { bg: '#FFEBEE', accent: '#FF1744' }, { bg: '#E1F5FE', accent: '#29B6F6' }
        ];
        const theme = palettes[Math.floor(Math.random() * palettes.length)];
        const patternType = Math.floor(Math.random() * 3); 

        ctx.fillStyle = theme.bg; ctx.fillRect(0,0,512,512);
        ctx.fillStyle = theme.accent; ctx.globalAlpha = 0.3;

        if (patternType === 0) { 
            for(let x=32; x<512; x+=64) for(let y=32; y<512; y+=64) {
                ctx.beginPath(); ctx.arc(x, y, 16, 0, Math.PI*2); ctx.fill();
            }
        } else if (patternType === 1) { 
            ctx.lineWidth = 20; ctx.strokeStyle = theme.accent;
            for(let i=-512; i<1024; i+=64) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i+512, 512); ctx.stroke();
            }
        } else { 
            for(let i=0; i<30; i++){
                const cx = Math.random()*512, cy = Math.random()*512, s = 20+Math.random()*30;
                ctx.beginPath(); ctx.moveTo(cx, cy-s); ctx.lineTo(cx-s, cy+s); ctx.lineTo(cx+s, cy+s); ctx.fill();
            }
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
        return tex;
    }

    // --- SETUP ---
    if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js').then(r=>r.update());

    const startBtn = document.getElementById('startBtn');
    startBtn.addEventListener('click', () => {
        initAudio();
        if (!renderer) initThreeJS();
        requestPermissionAndStart();
    });

    async function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') await audioCtx.resume();
    }

    function requestPermissionAndStart() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => { 
                    if (response === 'granted') window.addEventListener('deviceorientation', handleOrientation);
                    startGame();
                })
                .catch(() => startGame());
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
            startGame();
        }
    }

    window.addEventListener('keydown', e => {
        keys[e.code] = true;
        if (!isPlaying && (e.code === 'Space' || e.code === 'Enter') && (Date.now() - gameEndedTime > 500)) {
            initAudio(); startGame();
        }
    });
    window.addEventListener('keyup', e => keys[e.code] = false);
    
    function onWindowResize() {
        if (!camera || !renderer) return;
        width = window.innerWidth; height = window.innerHeight;
        camera.aspect = width / height; camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        if (!isPlaying) resizeLogic(); else repositionCamera();
    }
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('orientationchange', () => { setTimeout(onWindowResize, 100); });

    // --- THREE.JS ---
    function initThreeJS() {
        if (typeof THREE === 'undefined') return false;
        scene = new THREE.Scene(); 
        scene.background = new THREE.Color(0x000000); 

        camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 5000);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        lightAmbient = new THREE.AmbientLight(0xffffff, 0.7); scene.add(lightAmbient);
        lightDir = new THREE.DirectionalLight(0xffffff, 0.6);
        lightDir.position.set(50, 200, 100); lightDir.castShadow = true;
        lightDir.shadow.mapSize.width = 2048; lightDir.shadow.mapSize.height = 2048;
        lightDir.shadow.camera.left = -1000; lightDir.shadow.camera.right = 1000;
        lightDir.shadow.camera.top = 1000; lightDir.shadow.camera.bottom = -1000;
        scene.add(lightDir);

        worldContainer = new THREE.Group(); scene.add(worldContainer);
        wallsGroup = new THREE.Group(); worldContainer.add(wallsGroup);

        const ballGeo = new THREE.SphereGeometry(1, 32, 32);
        const ballTex = createStripedBallTexture();
        const ballMat = new THREE.MeshStandardMaterial({ map: ballTex, roughness: 0.2, metalness: 0.1 });
        ballMesh = new THREE.Mesh(ballGeo, ballMat);
        ballMesh.castShadow = true; worldContainer.add(ballMesh);

        const goalGeo = new THREE.BoxGeometry(1, 0.1, 1);
        const goalMat = new THREE.MeshStandardMaterial({ 
            color: 0x00ff00, 
            emissive: 0x00aa00, 
            emissiveIntensity: 0.5,
            polygonOffset: true, polygonOffsetFactor: -4, polygonOffsetUnits: -4
        });
        goalMesh = new THREE.Mesh(goalGeo, goalMat);
        worldContainer.add(goalMesh);

        const floorGeo = new THREE.PlaneGeometry(1, 1); 
        const floorTex = createVibrantFloorTexture();
        const floorMat = new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.8 });
        floorMesh = new THREE.Mesh(floorGeo, floorMat);
        floorMesh.rotation.x = -Math.PI / 2; floorMesh.position.y = -0.5;
        floorMesh.receiveShadow = true; worldContainer.add(floorMesh);

        loop();
        return true;
    }

    // --- GAME LOGIC ---
    function startGame() {
        document.getElementById('overlay').style.opacity = '0';
        setTimeout(() => { document.getElementById('overlay').style.display = 'none'; }, 300);
        resizeLogic();
        generateMaze(); 
        
        const mazeWidth = COLS * cellSize;
        const mazeHeight = ROWS * cellSize;
        
        floorMesh.geometry.dispose();
        floorMesh.geometry = new THREE.PlaneGeometry(mazeWidth, mazeHeight);
        
        const newTex = createVibrantFloorTexture();
        const repX = Math.max(1, mazeWidth / 250);
        const repY = Math.max(1, mazeHeight / 250);
        newTex.repeat.set(repX, repY);
        floorMesh.material.map = newTex;

        build3DMaze();
        
        ball.r = cellSize * 0.35; 
        ballMesh.scale.set(ball.r, ball.r, ball.r);
        
        ball.x = cellSize / 2; ball.y = cellSize / 2;
        ball.vx = 0; ball.vy = 0;
        ballMesh.rotation.set(0,0,0);
        visualTiltX = 0; visualTiltY = 0;

        const offsetX = (COLS * cellSize) / 2;
        const offsetY = (ROWS * cellSize) / 2;
        goalMesh.position.set((goal.x*cellSize)+(cellSize/2)-offsetX, 0.05, (goal.y*cellSize)+(cellSize/2)-offsetY);
        goalMesh.scale.set(cellSize*0.8, 1, cellSize*0.8);

        startTime = Date.now(); 
        isPlaying = true; 
    }

    function resizeLogic() {
        width = window.innerWidth; height = window.innerHeight;
        const targetSize = Math.max(width, height) < 800 ? 40 : 65;
        COLS = Math.floor(width / targetSize); ROWS = Math.floor(height / targetSize);
        if (COLS < 2) COLS = 2; if (ROWS < 2) ROWS = 2;
        if (COLS % 2 === 0) COLS--; if (ROWS % 2 === 0) ROWS--;
        cellSize = Math.floor(Math.min((width - 20) / COLS, (height - 20) / ROWS));
        if (cellSize < 10) cellSize = 10;
        wallThicknessVal = Math.max(3, cellSize * 0.15);
    }

    function generateMaze() {
        maze = []; goal = { x: COLS - 1, y: ROWS - 1 };
        for (let y = 0; y < ROWS; y++) {
            let row = [];
            for (let x = 0; x < COLS; x++) row.push({ top: true, right: true, bottom: true, left: true, visited: false });
            maze.push(row);
        }
        let stack = [{x:0, y:0}]; maze[0][0].visited = true;
        while (stack.length > 0) {
            let cell = stack[stack.length - 1];
            let neighbors = [];
            const dirs = [ { nx: cell.x, ny: cell.y - 1, wall: 'top', opp: 'bottom' }, { nx: cell.x + 1, ny: cell.y, wall: 'right', opp: 'left' }, { nx: cell.x, ny: cell.y + 1, wall: 'bottom', opp: 'top' }, { nx: cell.x - 1, ny: cell.y, wall: 'left', opp: 'right' } ];
            for (let d of dirs) if (d.nx >= 0 && d.nx < COLS && d.ny >= 0 && d.ny < ROWS && !maze[d.ny][d.nx].visited) neighbors.push(d);
            if (neighbors.length > 0) {
                let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                maze[cell.y][cell.x][next.wall] = false; maze[next.ny][next.nx][next.opp] = false;
                maze[next.ny][next.nx].visited = true; stack.push({ x: next.nx, y: next.ny });
            } else stack.pop();
        }
    }

    function build3DMaze() {
        while(wallsGroup.children.length > 0) wallsGroup.remove(wallsGroup.children[0]);
        const hue = Math.random();
        const wallColor = new THREE.Color().setHSL(hue, 0.6, 0.3);
        currentWallMaterial = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.3, metalness: 0.2 });
        const wallHeight = cellSize * 0.55; 
        const offsetX = (COLS * cellSize) / 2; const offsetY = (ROWS * cellSize) / 2;
        const geometryV = new THREE.BoxGeometry(wallThicknessVal, wallHeight, cellSize + wallThicknessVal);
        const geometryH = new THREE.BoxGeometry(cellSize + wallThicknessVal, wallHeight, wallThicknessVal);

        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                let c = maze[y][x];
                let tx = (x * cellSize) - offsetX + (cellSize/2); let ty = (y * cellSize) - offsetY + (cellSize/2);
                if (c.top) createWall(geometryH, tx, ty - cellSize/2, currentWallMaterial, wallHeight);
                if (c.left) createWall(geometryV, tx - cellSize/2, ty, currentWallMaterial, wallHeight);
                if (y === ROWS - 1 && c.bottom) createWall(geometryH, tx, ty + cellSize/2, currentWallMaterial, wallHeight);
                if (x === COLS - 1 && c.right) createWall(geometryV, tx + cellSize/2, ty, currentWallMaterial, wallHeight);
            }
        }
        repositionCamera();
    }

    function createWall(geo, x, z, mat, h) {
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, h/2, z);
        mesh.castShadow = true; mesh.receiveShadow = true;
        wallsGroup.add(mesh);
    }

    function repositionCamera() {
        const mazeHeight = ROWS * cellSize;
        const fov = camera.fov * (Math.PI / 180);
        let dist = Math.abs(mazeHeight / (2 * Math.tan(fov / 2))) * 1.2; 
        camera.position.set(0, dist, 0); camera.lookAt(0, 0, 0);
        camera.position.z += dist * 0.1; camera.lookAt(0,0,0);
    }

    // --- PHYSICS / INPUT ---
    function handleOrientation(event) {
        let x = event.beta, y = event.gamma;
        if (x === null) x = 0; if (y === null) y = 0; 
        if (y > 25) y = 25; if (y < -25) y = -25;
        if (x > 25) x = 25; if (x < -25) x = -25;
        tiltX = x / 25; tiltY = -(y / 25);
    }

    function update() {
        try {
            // RESTART
            if (!isPlaying) {
                const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
                for (const gp of gamepads) {
                    if (gp && gp.buttons && gp.buttons[0] && gp.buttons[0].pressed) {
                        if (Date.now() - gameEndedTime > 500) { initAudio(); startGame(); }
                    }
                }
                return;
            }

            // INPUT
            let ax = 0, ay = 0;
            if (tiltX) ax += tiltX; if (tiltY) ay += tiltY; // Gyro
            if (keys.ArrowUp || keys.KeyW) ay -= 1;
            if (keys.ArrowDown || keys.KeyS) ay += 1;
            if (keys.ArrowLeft || keys.KeyA) ax -= 1;
            if (keys.ArrowRight || keys.KeyD) ax += 1;

            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            for (const gp of gamepads) {
                if (!gp) continue;
                if (Math.abs(gp.axes[0]) > 0.15) ax += gp.axes[0];
                if (Math.abs(gp.axes[1]) > 0.15) ay += gp.axes[1];
            }

            ax = Math.max(-1, Math.min(1, ax));
            ay = Math.max(-1, Math.min(1, ay));
            
            // Debug HUD
            document.getElementById('debug-hud').innerText = `X: ${ax.toFixed(2)} Y: ${ay.toFixed(2)} Ball: ${Math.round(ball.x)},${Math.round(ball.y)}`;

            // SMOOTH TILT
            visualTiltX += ((ax - visualTiltX) * 0.1);
            visualTiltY += ((ay - visualTiltY) * 0.1);

            // VELOCITY
            if (isNaN(ball.vx)) ball.vx = 0;
            if (isNaN(ball.vy)) ball.vy = 0;

            ball.vx += ax * 0.8; 
            ball.vy += ay * 0.8;
            ball.vx *= 0.92; 
            ball.vy *= 0.92;

            const steps = 8; 
            const subVx = ball.vx / steps; 
            const subVy = ball.vy / steps;
            
            for (let i = 0; i < steps; i++) {
                ball.x += subVx; 
                ball.y += subVy; 
                solveCollisions(); 
            }

            // CHECK WIN
            let pcx = Math.floor(ball.x / cellSize); 
            let pcy = Math.floor(ball.y / cellSize);
            if (pcx === goal.x && pcy === goal.y) winGame();

            // SYNC VISUALS
            const offsetX = (COLS * cellSize) / 2; const offsetY = (ROWS * cellSize) / 2;
            ballMesh.position.x = ball.x - offsetX;
            ballMesh.position.z = ball.y - offsetY;
            ballMesh.position.y = ball.r;
            ballMesh.rotation.x -= ball.vy * 0.05; 
            ballMesh.rotation.z -= ball.vx * 0.05;

            worldContainer.rotation.x = visualTiltY * 0.25;
            worldContainer.rotation.z = -visualTiltX * 0.25; 
        } catch(e) {
            console.error("Physics Crash:", e);
            document.getElementById('debug-hud').innerText = "CRASH: " + e.message;
        }
    }

    function winGame() {
        if (!isPlaying) return; 
        isPlaying = false; 
        gameEndedTime = Date.now();
        playWinSound();
        const duration = ((Date.now() - startTime) / 1000).toFixed(2);
        
        const overlay = document.getElementById('overlay');
        document.getElementById('titleText').innerText = "MAZE COMPLETE!";
        document.getElementById('stats').innerText = `Time: ${duration}s`;
        document.getElementById('subText').innerText = "Press 'Space' or 'A' to Continue";
        document.getElementById('startBtn').innerText = "NEXT LEVEL";
        
        overlay.style.display = 'flex';
        setTimeout(() => { overlay.style.opacity = '1'; }, 10);
    }

    function solveCollisions() {
        // WORLD BOUNDS - Hard Clamp to prevent out-of-bounds array access
        if (ball.x < ball.r) { ball.x = ball.r; bounceX(); }
        if (ball.y < ball.r) { ball.y = ball.r; bounceY(); }
        if (ball.x > (COLS * cellSize) - ball.r) { ball.x = (COLS * cellSize) - ball.r; bounceX(); }
        if (ball.y > (ROWS * cellSize) - ball.r) { ball.y = (ROWS * cellSize) - ball.r; bounceY(); }

        let cx = Math.floor(ball.x / cellSize);
        let cy = Math.floor(ball.y / cellSize);
        
        // Safety Clamps for Array Access
        cx = Math.max(0, Math.min(COLS - 1, cx));
        cy = Math.max(0, Math.min(ROWS - 1, cy));

        const minX = Math.max(0, cx - 1);
        const maxX = Math.min(COLS - 1, cx + 1);
        const minY = Math.max(0, cy - 1);
        const maxY = Math.min(ROWS - 1, cy + 1);

        for (let y = minY; y <= maxY; y++) {
            for (let x = minX; x <= maxX; x++) {
                if (!maze[y] || !maze[y][x]) continue; // Prevent Crash
                let cell = maze[y][x];
                let tx = x * cellSize;
                let ty = y * cellSize;

                if (cell.top) resolveAABB(tx + cellSize/2, ty, cellSize + wallThicknessVal, wallThicknessVal);
                if (cell.left) resolveAABB(tx, ty + cellSize/2, wallThicknessVal, cellSize + wallThicknessVal);
                if (y === ROWS - 1 && cell.bottom) resolveAABB(tx + cellSize/2, ty + cellSize, cellSize + wallThicknessVal, wallThicknessVal);
                if (x === COLS - 1 && cell.right) resolveAABB(tx + cellSize, ty + cellSize/2, wallThicknessVal, cellSize + wallThicknessVal);
            }
        }
    }

    function resolveAABB(wx, wy, ww, wh) {
        let closestX = Math.max(wx - ww/2, Math.min(ball.x, wx + ww/2));
        let closestY = Math.max(wy - wh/2, Math.min(ball.y, wy + wh/2));
        let dx = ball.x - closestX;
        let dy = ball.y - closestY;
        let distSq = dx*dx + dy*dy;

        if (distSq < ball.r * ball.r && distSq > 0.00001) {
            let dist = Math.sqrt(distSq);
            let overlap = ball.r - dist;
            let nx = dx / dist;
            let ny = dy / dist;

            ball.x += nx * overlap;
            ball.y += ny * overlap;

            let dot = ball.vx * nx + ball.vy * ny;
            if (dot < 0) {
                let tx = ball.vx - nx * dot;
                let ty = ball.vy - ny * dot;
                tx *= 0.99; ty *= 0.99; 
                let restitution = 0.3;
                let bx = nx * dot * -restitution;
                let by = ny * dot * -restitution;
                ball.vx = tx + bx;
                ball.vy = ty + by;
                if (Math.abs(dot) > 1.5) playBump();
            }
        }
    }
    
    function bounceX() { ball.vx *= -0.3; if(Math.abs(ball.vx) > 1.5) playBump(); }
    function bounceY() { ball.vy *= -0.3; if(Math.abs(ball.vy) > 1.5) playBump(); }

    function playBump() {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        if (Date.now() - lastBumpTime < 200) return; lastBumpTime = Date.now();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine'; osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.8, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(now + (i * 0.1));
    }

    function playWinSound() {
        if (!audioCtx) return; const now = audioCtx.currentTime;
        [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.type = 'sine'; osc.frequency.setValueAtTime(freq, now + (i * 0.1));
            gain.gain.setValueAtTime(0, now + (i * 0.1));
            gain.gain.linearRampToValueAtTime(0.2, now + (i * 0.1) + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, now + (i * 0.1) + 0.4);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(now + (i * 0.1)); osc.stop(now + (i * 0.1) + 0.5);
        });
    }

    // LOOP: Resilience - If Update Fails, Keep Rendering
    function loop() {
        requestAnimationFrame(loop);
        update(); 
        if (renderer && scene && camera) renderer.render(scene, camera);
    }
</script>
</body>
</html>