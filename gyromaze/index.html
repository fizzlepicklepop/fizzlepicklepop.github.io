<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gyro Maze Final</title>
    <link rel="manifest" href="manifest.json">
    <style>
        body { margin: 0; overflow: hidden; background: #eee; touch-action: none; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; }
        canvas { display: block; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.95); color: #333; display: flex;
            justify-content: center; align-items: center; flex-direction: column;
            z-index: 10; text-align: center; transition: opacity 0.3s;
        }

        #rotate-message {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; color: white; z-index: 20;
            flex-direction: column; justify-content: center; align-items: center; text-align: center;
        }

        h1 { margin: 0 0 10px 0; font-size: 3rem; color: #ff3333; text-transform: uppercase; letter-spacing: 2px; }
        p { color: #666; font-size: 1.2rem; margin-bottom: 30px; font-weight: 500; }
        .stats { font-size: 1.5rem; color: #333; margin-bottom: 20px; font-weight: bold; }
        
        button {
            padding: 20px 60px; font-size: 1.5rem; background: #ff3333;
            border: none; border-radius: 50px; cursor: pointer; color: white; font-weight: bold;
            box-shadow: 0 5px 15px rgba(255, 51, 51, 0.4);
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }

        @media screen and (orientation: portrait) {
            #rotate-message { display: flex; }
            #overlay, canvas { display: none; }
        }
    </style>
</head>
<body>

<div id="rotate-message">
    <h1>Please Rotate</h1>
    <p>Landscape Mode Required</p>
    <div style="font-size: 3rem;">↻</div>
</div>

<div id="overlay">
    <h1 id="titleText">Gyro Maze</h1>
    <p id="subText">Tilt to Roll • Sound On</p>
    <div id="stats" class="stats"></div>
    <button id="startBtn">PLAY</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    // --- VARIABLES ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); 
    
    let width, height, cellSize;
    let COLS, ROWS;
    let maze = [];
    let ball = { x: 0, y: 0, r: 0, vx: 0, vy: 0 };
    let goal = { x: 0, y: 0 };
    
    let startTime = 0;
    let isPlaying = false;
    
    let wallPattern;
    let backgroundPattern;

    let tiltX = 0, tiltY = 0;
    let keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

    let audioCtx = null;

    // --- SETUP ---
    if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');

    document.getElementById('startBtn').addEventListener('click', async () => {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();

        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const response = await DeviceOrientationEvent.requestPermission();
                if (response === 'granted') window.addEventListener('deviceorientation', handleOrientation);
            } catch (e) { console.error(e); }
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
        }
        
        startGame();
    });

    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    
    window.addEventListener('resize', () => { 
        if(!isPlaying) resize(); 
        else {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
    });

    // --- AUDIO ---
    function playBump(force) {
        if (!audioCtx) return;
        if (force < 1.0) return; // Lower threshold slightly

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(150 + Math.random() * 50, audioCtx.currentTime);
        
        const vol = Math.min(0.8, force / 15);
        
        gain.gain.setValueAtTime(0, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        osc.start();
        osc.stop(audioCtx.currentTime + 0.15);
    }

    function playWinSound() {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const notes = [523.25, 659.25, 783.99, 1046.50]; 
        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(freq, now + (i * 0.1));
            gain.gain.setValueAtTime(0, now + (i * 0.1));
            gain.gain.linearRampToValueAtTime(0.3, now + (i * 0.1) + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, now + (i * 0.1) + 0.4);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now + (i * 0.1));
            osc.stop(now + (i * 0.1) + 0.5);
        });
    }

    // --- GAME ---

    function startGame() {
        document.getElementById('overlay').style.opacity = '0';
        setTimeout(() => { document.getElementById('overlay').style.display = 'none'; }, 300);
        
        resize();
        wallPattern = createWallPattern();
        backgroundPattern = createBrightBackground();
        generateMaze();
        
        ball.r = cellSize * 0.35;
        ball.x = cellSize / 2;
        ball.y = cellSize / 2;
        ball.vx = 0; ball.vy = 0;

        startTime = Date.now();
        isPlaying = true;
        loop();
    }

    function winGame() {
        if (!isPlaying) return;
        isPlaying = false;
        playWinSound();

        const endTime = Date.now();
        const duration = ((endTime - startTime) / 1000).toFixed(2);

        const overlay = document.getElementById('overlay');
        const title = document.getElementById('titleText');
        const sub = document.getElementById('subText');
        const stats = document.getElementById('stats');
        const btn = document.getElementById('startBtn');

        title.innerText = "MAZE COMPLETE!";
        title.style.color = "#00aa00";
        sub.innerText = "Nice moves.";
        stats.innerText = `Time: ${duration}s`;
        btn.innerText = "NEXT LEVEL";

        overlay.style.display = 'flex';
        setTimeout(() => { overlay.style.opacity = '1'; }, 10);
    }

    function createWallPattern() {
        const s = 64;
        const c = document.createElement('canvas');
        c.width = s; c.height = s;
        const cx = c.getContext('2d');
        cx.fillStyle = '#222'; cx.fillRect(0,0,s,s);
        cx.strokeStyle = '#444'; cx.lineWidth = 2;
        cx.strokeRect(0,0,s,s);
        cx.beginPath(); cx.moveTo(0,0); cx.lineTo(s,s); cx.stroke();
        return ctx.createPattern(c, 'repeat');
    }

    function createBrightBackground() {
        const s = 100;
        const c = document.createElement('canvas');
        c.width = s; c.height = s;
        const cx = c.getContext('2d');
        const hues = ['#e0f7fa', '#fff9c4', '#f1f8e9', '#e1bee7', '#ffe0b2', '#ffffff'];
        cx.fillStyle = hues[Math.floor(Math.random() * hues.length)];
        cx.fillRect(0, 0, s, s);
        cx.fillStyle = 'rgba(0,0,0,0.05)';
        cx.beginPath(); cx.arc(50, 50, 20, 0, Math.PI*2); cx.fill();
        return ctx.createPattern(c, 'repeat');
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        // iPad Tuning
        const targetSize = Math.max(width, height) < 800 ? 40 : 65;
        COLS = Math.floor(width / targetSize);
        ROWS = Math.floor(height / targetSize);
        if (COLS % 2 === 0) COLS--;
        if (ROWS % 2 === 0) ROWS--;
        
        // Add padding calculation to prevent clipping
        cellSize = Math.floor(Math.min((width - 20) / COLS, (height - 20) / ROWS));
    }

    function generateMaze() {
        maze = [];
        goal = { x: COLS - 1, y: ROWS - 1 };
        for (let y = 0; y < ROWS; y++) {
            let row = [];
            for (let x = 0; x < COLS; x++) row.push({ top: true, right: true, bottom: true, left: true, visited: false });
            maze.push(row);
        }
        let stack = [{x:0, y:0}];
        maze[0][0].visited = true;
        while (stack.length > 0) {
            let cell = stack[stack.length - 1];
            let neighbors = [];
            const dirs = [
                { nx: cell.x, ny: cell.y - 1, wall: 'top', opp: 'bottom' },
                { nx: cell.x + 1, ny: cell.y, wall: 'right', opp: 'left' },
                { nx: cell.x, ny: cell.y + 1, wall: 'bottom', opp: 'top' },
                { nx: cell.x - 1, ny: cell.y, wall: 'left', opp: 'right' }
            ];
            for (let d of dirs) {
                if (d.nx >= 0 && d.nx < COLS && d.ny >= 0 && d.ny < ROWS && !maze[d.ny][d.nx].visited) neighbors.push(d);
            }
            if (neighbors.length > 0) {
                let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                maze[cell.y][cell.x][next.wall] = false;
                maze[next.ny][next.nx][next.opp] = false;
                maze[next.ny][next.nx].visited = true;
                stack.push({ x: next.nx, y: next.ny });
            } else stack.pop();
        }
    }

    function handleOrientation(event) {
        const maxTilt = 25;
        let beta = event.beta;
        let gamma = event.gamma;
        
        let x = beta; 
        let y = gamma;

        if (y > maxTilt) y = maxTilt; if (y < -maxTilt) y = -maxTilt;
        if (x > maxTilt) x = maxTilt; if (x < -maxTilt) x = -maxTilt;

        tiltX = x / maxTilt; 
        tiltY = -(y / maxTilt); // Inverted Y for natural feel
    }

    function update() {
        if (!isPlaying) return;

        let dx = 0, dy = 0;
        if (keys.ArrowUp || keys.KeyW) dy = -1;
        if (keys.ArrowDown || keys.KeyS) dy = 1;
        if (keys.ArrowLeft || keys.KeyA) dx = -1;
        if (keys.ArrowRight || keys.KeyD) dx = 1;

        let ax = dx !== 0 ? dx : tiltX;
        let ay = dy !== 0 ? dy : tiltY;

        ball.vx += ax * 0.8;
        ball.vy += ay * 0.8;
        ball.vx *= 0.92;
        ball.vy *= 0.92;

        ball.x += ball.vx;
        checkCollisionX();
        ball.y += ball.vy;
        checkCollisionY();

        let pcx = Math.floor(ball.x / cellSize);
        let pcy = Math.floor(ball.y / cellSize);
        if (pcx === goal.x && pcy === goal.y) {
            winGame();
        }
    }

    // --- PHYSICS + SOUND FIXES ---

    function checkCollisionX() {
        // SCREEN BOUNDARY CHECKS
        if (ball.x - ball.r < 0) { 
            ball.x = ball.r; 
            if(Math.abs(ball.vx) > 0) playBump(Math.abs(ball.vx)); // Play Sound
            ball.vx = 0; 
        }
        if (ball.x + ball.r > COLS * cellSize) { 
            ball.x = COLS * cellSize - ball.r; 
            if(Math.abs(ball.vx) > 0) playBump(Math.abs(ball.vx)); // Play Sound
            ball.vx = 0; 
        }

        let cx = Math.floor(ball.x / cellSize);
        let cy = Math.floor(ball.y / cellSize);
        cx = Math.max(0, Math.min(COLS-1, cx));
        cy = Math.max(0, Math.min(ROWS-1, cy));
        
        let cell = maze[cy][cx];
        let localX = ball.x % cellSize;

        if (cell.right && localX + ball.r > cellSize) { 
            if(Math.abs(ball.vx) > 0) playBump(Math.abs(ball.vx));
            ball.x = (cx + 1) * cellSize - ball.r; 
            ball.vx *= -0.3; 
        }
        if (cell.left && localX - ball.r < 0) { 
            if(Math.abs(ball.vx) > 0) playBump(Math.abs(ball.vx));
            ball.x = cx * cellSize + ball.r; 
            ball.vx *= -0.3; 
        }
    }

    function checkCollisionY() {
        // SCREEN BOUNDARY CHECKS
        if (ball.y - ball.r < 0) { 
            ball.y = ball.r; 
            if(Math.abs(ball.vy) > 0) playBump(Math.abs(ball.vy)); // Play Sound
            ball.vy = 0; 
        }
        if (ball.y + ball.r > ROWS * cellSize) { 
            ball.y = ROWS * cellSize - ball.r; 
            if(Math.abs(ball.vy) > 0) playBump(Math.abs(ball.vy)); // Play Sound
            ball.vy = 0; 
        }

        let cx = Math.floor(ball.x / cellSize);
        let cy = Math.floor(ball.y / cellSize);
        cx = Math.max(0, Math.min(COLS-1, cx));
        cy = Math.max(0, Math.min(ROWS-1, cy));

        let cell = maze[cy][cx];
        let localY = ball.y % cellSize;

        if (cell.bottom && localY + ball.r > cellSize) { 
            if(Math.abs(ball.vy) > 0) playBump(Math.abs(ball.vy));
            ball.y = (cy + 1) * cellSize - ball.r; 
            ball.vy *= -0.3; 
        }
        if (cell.top && localY - ball.r < 0) { 
            if(Math.abs(ball.vy) > 0) playBump(Math.abs(ball.vy));
            ball.y = cy * cellSize + ball.r; 
            ball.vy *= -0.3; 
        }
    }

    function draw() {
        if (!isPlaying) return;

        ctx.fillStyle = backgroundPattern;
        ctx.fillRect(0, 0, width, height);

        let offsetX = (width - COLS * cellSize) / 2;
        let offsetY = (height - ROWS * cellSize) / 2;

        ctx.save();
        ctx.translate(offsetX, offsetY);

        // Goal
        ctx.fillStyle = 'rgba(0, 200, 0, 0.5)';
        ctx.fillRect(goal.x * cellSize, goal.y * cellSize, cellSize, cellSize);
        ctx.strokeStyle = '#00aa00'; ctx.lineWidth = 3;
        ctx.strokeRect(goal.x * cellSize + 8, goal.y * cellSize + 8, cellSize - 16, cellSize - 16);

        // Walls
        ctx.strokeStyle = wallPattern; ctx.lineWidth = 6; ctx.lineCap = 'round';
        ctx.beginPath();
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                let c = maze[y][x];
                let tx = x * cellSize; let ty = y * cellSize;
                if (c.top) { ctx.moveTo(tx, ty); ctx.lineTo(tx + cellSize, ty); }
                if (c.left) { ctx.moveTo(tx, ty); ctx.lineTo(tx, ty + cellSize); }
                if (y === ROWS - 1 && c.bottom) { ctx.moveTo(tx, ty + cellSize); ctx.lineTo(tx + cellSize, ty + cellSize); }
                if (x === COLS - 1 && c.right) { ctx.moveTo(tx + cellSize, ty); ctx.lineTo(tx + cellSize, ty + cellSize); }
            }
        }
        ctx.stroke();

        // ** DRAW OUTER BORDER MANUALLY **
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 8;
        ctx.strokeRect(0, 0, COLS * cellSize, ROWS * cellSize);

        // Ball
        ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2); ctx.fill();
        let grad = ctx.createRadialGradient(ball.x - ball.r * 0.3, ball.y - ball.r * 0.3, ball.r * 0.1, ball.x, ball.y, ball.r);
        grad.addColorStop(0, 'rgba(255, 255, 255, 0.5)'); grad.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2); ctx.fill();

        ctx.restore();
    }

    function loop() {
        update();
        draw();
        if (isPlaying) requestAnimationFrame(loop);
    }
</script>
</body>
</html>