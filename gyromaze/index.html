<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gyro Maze</title>
    <link rel="manifest" href="manifest.json">
    <style>
        body { margin: 0; overflow: hidden; background: #222; touch-action: none; font-family: sans-serif; }
        canvas { display: block; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); color: white; display: flex;
            justify-content: center; align-items: center; flex-direction: column;
            z-index: 10; text-align: center;
        }
        button {
            padding: 15px 30px; font-size: 1.2rem; background: #00d2ff; border: none;
            border-radius: 8px; cursor: pointer; margin-top: 20px; color: #000; font-weight: bold;
        }
    </style>
</head>
<body>

<div id="overlay">
    <h1>Gyro Maze PWA</h1>
    <p>Tilt your phone or use Arrow Keys</p>
    <button id="startBtn">START GAME</button>
</div>
<canvas id="gameCanvas"></canvas>

<script>
    // --- CONFIGURATION ---
    const COLS = 15;
    const ROWS = 15;
    const WALL_THICKNESS = 4;
    
    // --- VARIABLES ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let width, height, cellSize;
    let maze = []; // 2D array: { top, right, bottom, left, visited }
    let ball = { x: 0, y: 0, r: 0, vx: 0, vy: 0 };
    let goal = { x: COLS - 1, y: ROWS - 1 };
    
    // Textures
    let wallPattern;
    let floorPattern;

    // Inputs
    let tiltX = 0, tiltY = 0; // Gyro
    let keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

    // --- SETUP & PWA ---
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js');
    }

    document.getElementById('startBtn').addEventListener('click', async () => {
        // Request Gyro Permission (Required for iOS 13+)
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const response = await DeviceOrientationEvent.requestPermission();
                if (response === 'granted') window.addEventListener('deviceorientation', handleOrientation);
            } catch (e) { console.error(e); }
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
        }
        
        document.getElementById('overlay').style.display = 'none';
        initGame();
        loop();
    });

    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    window.addEventListener('resize', resize);

    // --- GENERATION ---
    function initGame() {
        resize();
        generateTextures();
        generateMaze();
        // Reset Ball to center of top-left cell
        ball.x = cellSize / 2;
        ball.y = cellSize / 2;
        ball.r = cellSize * 0.3;
        ball.vx = 0; ball.vy = 0;
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        // Calculate cell size to fit the smaller dimension
        cellSize = Math.floor(Math.min(width / COLS, height / ROWS));
    }

    function generateTextures() {
        // 1. Programmatic Wall Texture (Diagonal Stripes)
        const wCanvas = document.createElement('canvas');
        wCanvas.width = 20; wCanvas.height = 20;
        const wCtx = wCanvas.getContext('2d');
        wCtx.fillStyle = '#444'; wCtx.fillRect(0,0,20,20);
        wCtx.strokeStyle = '#666'; wCtx.lineWidth = 2;
        wCtx.beginPath(); wCtx.moveTo(0,20); wCtx.lineTo(20,0); wCtx.stroke();
        wallPattern = ctx.createPattern(wCanvas, 'repeat');

        // 2. Programmatic Floor Texture (Subtle Noise)
        const fCanvas = document.createElement('canvas');
        fCanvas.width = 50; fCanvas.height = 50;
        const fCtx = fCanvas.getContext('2d');
        fCtx.fillStyle = '#222'; fCtx.fillRect(0,0,50,50);
        fCtx.fillStyle = '#2a2a2a';
        for(let i=0; i<10; i++) fCtx.fillRect(Math.random()*50, Math.random()*50, 2, 2);
        floorPattern = ctx.createPattern(fCanvas, 'repeat');
    }

    function generateMaze() {
        maze = [];
        for (let y = 0; y < ROWS; y++) {
            let row = [];
            for (let x = 0; x < COLS; x++) {
                row.push({ top: true, right: true, bottom: true, left: true, visited: false });
            }
            maze.push(row);
        }

        // Recursive Backtracker
        let stack = [];
        let current = { x: 0, y: 0 };
        maze[0][0].visited = true;
        stack.push(current);

        while (stack.length > 0) {
            let cell = stack[stack.length - 1];
            let neighbors = [];

            const dirs = [
                { nx: cell.x, ny: cell.y - 1, wall: 'top', opp: 'bottom' },
                { nx: cell.x + 1, ny: cell.y, wall: 'right', opp: 'left' },
                { nx: cell.x, ny: cell.y + 1, wall: 'bottom', opp: 'top' },
                { nx: cell.x - 1, ny: cell.y, wall: 'left', opp: 'right' }
            ];

            for (let d of dirs) {
                if (d.nx >= 0 && d.nx < COLS && d.ny >= 0 && d.ny < ROWS && !maze[d.ny][d.nx].visited) {
                    neighbors.push(d);
                }
            }

            if (neighbors.length > 0) {
                let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                maze[cell.y][cell.x][next.wall] = false;
                maze[next.ny][next.nx][next.opp] = false;
                maze[next.ny][next.nx].visited = true;
                stack.push({ x: next.nx, y: next.ny });
            } else {
                stack.pop();
            }
        }
    }

    // --- INPUT HANDLING ---
    function handleOrientation(event) {
        // Beta: front/back (-180 to 180), Gamma: left/right (-90 to 90)
        // We clamp values to make control easier
        const maxTilt = 20;
        let y = event.beta; 
        let x = event.gamma; 

        if (y > maxTilt) y = maxTilt; if (y < -maxTilt) y = -maxTilt;
        if (x > maxTilt) x = maxTilt; if (x < -maxTilt) x = -maxTilt;

        tiltX = x / maxTilt; // Normalized -1 to 1
        tiltY = y / maxTilt;
    }

    // --- GAME LOOP ---
    function update() {
        // Keyboard Override
        let dx = 0, dy = 0;
        if (keys.ArrowUp || keys.KeyW) dy = -1;
        if (keys.ArrowDown || keys.KeyS) dy = 1;
        if (keys.ArrowLeft || keys.KeyA) dx = -1;
        if (keys.ArrowRight || keys.KeyD) dx = 1;

        // Combine inputs (Keyboard overrides tilt if used)
        let ax = dx !== 0 ? dx : tiltX;
        let ay = dy !== 0 ? dy : tiltY;

        // Physics
        ball.vx += ax * 0.5;
        ball.vy += ay * 0.5;
        ball.vx *= 0.9; // Friction
        ball.vy *= 0.9;

        // Proposed next position
        let nextX = ball.x + ball.vx;
        let nextY = ball.y + ball.vy;

        // Collision Detection (Wall Sliding)
        let colX = Math.floor(ball.x / cellSize);
        let colY = Math.floor(ball.y / cellSize);
        
        // Keep inside canvas bounds
        if (nextX - ball.r < 0) { nextX = ball.r; ball.vx = 0; }
        if (nextX + ball.r > COLS * cellSize) { nextX = COLS * cellSize - ball.r; ball.vx = 0; }
        if (nextY - ball.r < 0) { nextY = ball.r; ball.vy = 0; }
        if (nextY + ball.r > ROWS * cellSize) { nextY = ROWS * cellSize - ball.r; ball.vy = 0; }

        // Check Walls logic (Simplified for grid)
        // We check if the ball crosses a cell boundary and if that boundary has a wall
        let currentCell = maze[Math.min(ROWS-1, Math.max(0, Math.floor(ball.y / cellSize)))][Math.min(COLS-1, Math.max(0, Math.floor(ball.x / cellSize)))];
        
        // Relative position in cell
        let localX = ball.x % cellSize;
        let localY = ball.y % cellSize;

        // Right Wall
        if (currentCell.right && localX + ball.vx + ball.r > cellSize) {
            ball.vx = -ball.vx * 0.3; // Bounce slightly
        }
        // Left Wall
        if (currentCell.left && localX + ball.vx - ball.r < 0) {
            ball.vx = -ball.vx * 0.3;
        }
        // Bottom Wall
        if (currentCell.bottom && localY + ball.vy + ball.r > cellSize) {
            ball.vy = -ball.vy * 0.3;
        }
        // Top Wall
        if (currentCell.top && localY + ball.vy - ball.r < 0) {
            ball.vy = -ball.vy * 0.3;
        }

        ball.x += ball.vx;
        ball.y += ball.vy;
        
        // Win Condition
        let pCol = Math.floor(ball.x / cellSize);
        let pRow = Math.floor(ball.y / cellSize);
        if (pCol === goal.x && pRow === goal.y) {
            alert("You Win! Generating new maze...");
            initGame();
        }
    }

    function draw() {
        // Clear
        ctx.fillStyle = floorPattern;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Center the view (optional, but here we fit screen so we just draw grid)
        // Calculate offset to center the maze on screen
        let offsetX = (width - COLS * cellSize) / 2;
        let offsetY = (height - ROWS * cellSize) / 2;

        ctx.save();
        ctx.translate(offsetX, offsetY);

        // Draw Walls
        ctx.strokeStyle = wallPattern;
        ctx.lineWidth = WALL_THICKNESS;
        ctx.lineCap = 'round';
        ctx.beginPath();

        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                let cell = maze[y][x];
                let cx = x * cellSize;
                let cy = y * cellSize;

                if (cell.top) { ctx.moveTo(cx, cy); ctx.lineTo(cx + cellSize, cy); }
                if (cell.left) { ctx.moveTo(cx, cy); ctx.lineTo(cx, cy + cellSize); }
                // Only draw bottom/right for last row/col to avoid double drawing
                if (y === ROWS - 1 && cell.bottom) { ctx.moveTo(cx, cy + cellSize); ctx.lineTo(cx + cellSize, cy + cellSize); }
                if (x === COLS - 1 && cell.right) { ctx.moveTo(cx + cellSize, cy); ctx.lineTo(cx + cellSize, cy + cellSize); }
            }
        }
        ctx.stroke();

        // Draw Goal
        ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.fillRect(goal.x * cellSize + 5, goal.y * cellSize + 5, cellSize - 10, cellSize - 10);

        // Draw Ball (Programmatic Gradient)
        let grad = ctx.createRadialGradient(ball.x, ball.y, ball.r * 0.2, ball.x, ball.y, ball.r);
        grad.addColorStop(0, '#fff');
        grad.addColorStop(1, '#00d2ff');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }
</script>
</body>
</html>