<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gyro Maze: Silky Smooth</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #111; touch-action: none; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; }
        
        canvas { 
            display: block; 
            position: absolute; 
            top: 0; left: 0; right: 0; bottom: 0; 
            width: 100%; height: 100%; 
            outline: none; 
        }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); color: #fff; display: flex;
            justify-content: center; align-items: center; flex-direction: column;
            z-index: 10; text-align: center; transition: opacity 0.3s;
            backdrop-filter: blur(5px);
        }

        #rotate-message {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: white; z-index: 20;
            flex-direction: column; justify-content: center; align-items: center; text-align: center;
        }

        h1 { margin: 0 0 10px 0; font-size: 3rem; color: #ff0055; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 20px #ff0055; }
        p { color: #aaa; font-size: 1.2rem; margin-bottom: 30px; font-weight: 500; }
        .stats { font-size: 1.5rem; color: #fff; margin-bottom: 20px; font-weight: bold; }
        
        button {
            padding: 20px 60px; font-size: 1.5rem; background: #ff0055;
            border: none; border-radius: 50px; cursor: pointer; color: #fff; font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button:active { transform: scale(0.95); box-shadow: 0 0 10px rgba(255, 0, 85, 0.6); }

        @media screen and (orientation: portrait) {
            #rotate-message { display: flex; }
            #overlay, canvas { display: none; }
        }
    </style>
</head>
<body>

<div id="rotate-message">
    <h1>Please Rotate</h1>
    <p>Landscape Mode Required</p>
    <div style="font-size: 3rem;">↻</div>
</div>

<div id="overlay">
    <h1 id="titleText">Gyro Maze</h1>
    <p id="subText">Tilt to Roll • Sound On</p>
    <div id="stats" class="stats"></div>
    <button id="startBtn">PLAY</button>
</div>

<script>
    // --- VARIABLES ---
    let width, height, cellSize;
    let COLS, ROWS;
    let maze = [];
    
    // Physics
    let ball = { x: 0, y: 0, r: 0, vx: 0, vy: 0 };
    let goal = { x: 0, y: 0 };
    let startTime = 0;
    let isPlaying = false;
    let tiltX = 0, tiltY = 0; 
    let visualTiltX = 0, visualTiltY = 0; 
    let keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
    let audioCtx = null;
    let lastBumpTime = 0;
    let wallThicknessVal = 0; 

    // Three.js
    let scene, camera, renderer;
    let worldContainer; 
    let ballMesh, goalMesh, floorMesh;
    let wallsGroup; 
    let lightDir, lightAmbient;
    let currentWallMaterial;

    // --- TEXTURES ---
    function createStripedBallTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 256; 
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,512,256);
        ctx.fillStyle = '#ff0033'; 
        [50, 100, 150, 200].forEach(y => ctx.fillRect(0, y, 512, 25));
        ctx.fillRect(0, 0, 512, 15); ctx.fillRect(0, 241, 512, 15); 
        return new THREE.CanvasTexture(canvas);
    }

    function createVibrantFloorTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        const palettes = [
            { bg: '#E0F7FA', accent: '#00BCD4' }, { bg: '#F3E5F5', accent: '#E040FB' },
            { bg: '#E8F5E9', accent: '#00E676' }, { bg: '#FFF3E0', accent: '#FF9100' },
            { bg: '#FFEBEE', accent: '#FF1744' }, { bg: '#E1F5FE', accent: '#29B6F6' }
        ];
        const theme = palettes[Math.floor(Math.random() * palettes.length)];
        const patternType = Math.floor(Math.random() * 3); 

        ctx.fillStyle = theme.bg; ctx.fillRect(0,0,512,512);
        ctx.fillStyle = theme.accent; ctx.globalAlpha = 0.3;

        if (patternType === 0) { // Dots
            for(let x=32; x<512; x+=64) for(let y=32; y<512; y+=64) {
                ctx.beginPath(); ctx.arc(x, y, 16, 0, Math.PI*2); ctx.fill();
            }
        } else if (patternType === 1) { // Stripes
            ctx.lineWidth = 20; ctx.strokeStyle = theme.accent;
            for(let i=-512; i<1024; i+=64) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i+512, 512); ctx.stroke();
            }
        } else { // Triangles
            for(let i=0; i<30; i++){
                const cx = Math.random()*512, cy = Math.random()*512, s = 20+Math.random()*30;
                ctx.beginPath(); ctx.moveTo(cx, cy-s); ctx.lineTo(cx-s, cy+s); ctx.lineTo(cx+s, cy+s); ctx.fill();
            }
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(8, 8); 
        return tex;
    }

    // --- SETUP ---
    if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');

    document.getElementById('startBtn').addEventListener('click', async () => {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();

        if (!renderer) {
            if (!initThreeJS()) { alert("WebGL failed."); return; }
        }

        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const response = await DeviceOrientationEvent.requestPermission();
                if (response === 'granted') window.addEventListener('deviceorientation', handleOrientation);
            } catch (e) { console.error(e); }
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
        }
        startGame();
    });

    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    
    function onWindowResize() {
        if (!camera || !renderer) return;
        width = window.innerWidth; height = window.innerHeight;
        camera.aspect = width / height; camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        if (!isPlaying) resizeLogic(); else repositionCamera();
    }
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('orientationchange', () => { setTimeout(onWindowResize, 100); });

    // --- THREE.JS ---
    function initThreeJS() {
        if (typeof THREE === 'undefined') return false;
        scene = new THREE.Scene(); scene.background = new THREE.Color(0x111111);
        camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 5000);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        lightAmbient = new THREE.AmbientLight(0xffffff, 0.7); scene.add(lightAmbient);
        lightDir = new THREE.DirectionalLight(0xffffff, 0.6);
        lightDir.position.set(50, 200, 100); lightDir.castShadow = true;
        lightDir.shadow.mapSize.width = 2048; lightDir.shadow.mapSize.height = 2048;
        lightDir.shadow.camera.left = -1000; lightDir.shadow.camera.right = 1000;
        lightDir.shadow.camera.top = 1000; lightDir.shadow.camera.bottom = -1000;
        scene.add(lightDir);

        worldContainer = new THREE.Group(); scene.add(worldContainer);
        wallsGroup = new THREE.Group(); worldContainer.add(wallsGroup);

        const ballGeo = new THREE.SphereGeometry(1, 32, 32);
        const ballTex = createStripedBallTexture();
        const ballMat = new THREE.MeshStandardMaterial({ map: ballTex, roughness: 0.2, metalness: 0.1 });
        ballMesh = new THREE.Mesh(ballGeo, ballMat);
        ballMesh.castShadow = true; worldContainer.add(ballMesh);

        // Z-Fighting Fix
        const goalGeo = new THREE.BoxGeometry(1, 0.1, 1);
        const goalMat = new THREE.MeshStandardMaterial({ 
            color: 0x00ff00, 
            emissive: 0x00aa00, 
            emissiveIntensity: 0.5,
            polygonOffset: true, polygonOffsetFactor: -4, polygonOffsetUnits: -4
        });
        goalMesh = new THREE.Mesh(goalGeo, goalMat);
        worldContainer.add(goalMesh);

        const floorGeo = new THREE.PlaneGeometry(5000, 5000);
        const floorTex = createVibrantFloorTexture();
        const floorMat = new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.8 });
        floorMesh = new THREE.Mesh(floorGeo, floorMat);
        floorMesh.rotation.x = -Math.PI / 2; floorMesh.position.y = -0.5;
        floorMesh.receiveShadow = true; worldContainer.add(floorMesh);

        return true;
    }

    // --- GAME LOGIC ---
    function startGame() {
        document.getElementById('overlay').style.opacity = '0';
        setTimeout(() => { document.getElementById('overlay').style.display = 'none'; }, 300);
        resizeLogic();
        floorMesh.material.map = createVibrantFloorTexture();
        generateMaze(); build3DMaze();
        
        ball.r = cellSize * 0.35; 
        ballMesh.scale.set(ball.r, ball.r, ball.r);
        
        ball.x = cellSize / 2; ball.y = cellSize / 2;
        ball.vx = 0; ball.vy = 0;
        ballMesh.rotation.set(0,0,0);
        visualTiltX = 0; visualTiltY = 0;

        const offsetX = (COLS * cellSize) / 2;
        const offsetY = (ROWS * cellSize) / 2;
        
        goalMesh.position.set((goal.x*cellSize)+(cellSize/2)-offsetX, 0.05, (goal.y*cellSize)+(cellSize/2)-offsetY);
        goalMesh.scale.set(cellSize*0.8, 1, cellSize*0.8);

        startTime = Date.now(); isPlaying = true; loop();
    }

    function resizeLogic() {
        width = window.innerWidth; height = window.innerHeight;
        const targetSize = Math.max(width, height) < 800 ? 40 : 65;
        COLS = Math.floor(width / targetSize); ROWS = Math.floor(height / targetSize);
        if (COLS < 2) COLS = 2; if (ROWS < 2) ROWS = 2;
        if (COLS % 2 === 0) COLS--; if (ROWS % 2 === 0) ROWS--;
        cellSize = Math.floor(Math.min((width - 20) / COLS, (height - 20) / ROWS));
        if (cellSize < 10) cellSize = 10;
        
        wallThicknessVal = Math.max(3, cellSize * 0.15);
    }

    function generateMaze() {
        maze = []; goal = { x: COLS - 1, y: ROWS - 1 };
        for (let y = 0; y < ROWS; y++) {
            let row = [];
            for (let x = 0; x < COLS; x++) row.push({ top: true, right: true, bottom: true, left: true, visited: false });
            maze.push(row);
        }
        let stack = [{x:0, y:0}]; maze[0][0].visited = true;
        while (stack.length > 0) {
            let cell = stack[stack.length - 1];
            let neighbors = [];
            const dirs = [ { nx: cell.x, ny: cell.y - 1, wall: 'top', opp: 'bottom' }, { nx: cell.x + 1, ny: cell.y, wall: 'right', opp: 'left' }, { nx: cell.x, ny: cell.y + 1, wall: 'bottom', opp: 'top' }, { nx: cell.x - 1, ny: cell.y, wall: 'left', opp: 'right' } ];
            for (let d of dirs) if (d.nx >= 0 && d.nx < COLS && d.ny >= 0 && d.ny < ROWS && !maze[d.ny][d.nx].visited) neighbors.push(d);
            if (neighbors.length > 0) {
                let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                maze[cell.y][cell.x][next.wall] = false; maze[next.ny][next.nx][next.opp] = false;
                maze[next.ny][next.nx].visited = true; stack.push({ x: next.nx, y: next.ny });
            } else stack.pop();
        }
    }

    function build3DMaze() {
        while(wallsGroup.children.length > 0) wallsGroup.remove(wallsGroup.children[0]);
        
        const hue = Math.random();
        const wallColor = new THREE.Color().setHSL(hue, 0.6, 0.3);
        currentWallMaterial = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.3, metalness: 0.2 });
        
        const wallHeight = cellSize * 0.55; 
        const offsetX = (COLS * cellSize) / 2; const offsetY = (ROWS * cellSize) / 2;

        const geometryV = new THREE.BoxGeometry(wallThicknessVal, wallHeight, cellSize + wallThicknessVal);
        const geometryH = new THREE.BoxGeometry(cellSize + wallThicknessVal, wallHeight, wallThicknessVal);

        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                let c = maze[y][x];
                let tx = (x * cellSize) - offsetX + (cellSize/2); let ty = (y * cellSize) - offsetY + (cellSize/2);
                if (c.top) createWall(geometryH, tx, ty - cellSize/2, currentWallMaterial, wallHeight);
                if (c.left) createWall(geometryV, tx - cellSize/2, ty, currentWallMaterial, wallHeight);
                if (y === ROWS - 1 && c.bottom) createWall(geometryH, tx, ty + cellSize/2, currentWallMaterial, wallHeight);
                if (x === COLS - 1 && c.right) createWall(geometryV, tx + cellSize/2, ty, currentWallMaterial, wallHeight);
            }
        }
        repositionCamera();
    }

    function createWall(geo, x, z, mat, h) {
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, h/2, z);
        mesh.castShadow = true; mesh.receiveShadow = true;
        wallsGroup.add(mesh);
    }

    function repositionCamera() {
        const mazeHeight = ROWS * cellSize;
        const fov = camera.fov * (Math.PI / 180);
        let dist = Math.abs(mazeHeight / (2 * Math.tan(fov / 2))) * 1.2; 
        camera.position.set(0, dist, 0); camera.lookAt(0, 0, 0);
        camera.position.z += dist * 0.1; camera.lookAt(0,0,0);
    }

    // --- PHYSICS ---
    function handleOrientation(event) {
        let x = event.beta, y = event.gamma;
        if (y > 25) y = 25; if (y < -25) y = -25;
        if (x > 25) x = 25; if (x < -25) x = -25;
        tiltX = x / 25; tiltY = -(y / 25);
    }

    function update() {
        if (!isPlaying) return;
        let keyDx = 0, keyDy = 0;
        if (keys.ArrowUp || keys.KeyW) keyDy = -1;
        if (keys.ArrowDown || keys.KeyS) keyDy = 1;
        if (keys.ArrowLeft || keys.KeyA) keyDx = -1;
        if (keys.ArrowRight || keys.KeyD) keyDx = 1;

        let ax = keyDx !== 0 ? keyDx : tiltX;
        let ay = keyDy !== 0 ? keyDy : tiltY;

        visualTiltX += ((keyDx !== 0 ? keyDx : tiltX) - visualTiltX) * 0.1;
        visualTiltY += ((keyDy !== 0 ? keyDy : tiltY) - visualTiltY) * 0.1;

        ball.vx += ax * 0.8; ball.vy += ay * 0.8;
        ball.vx *= 0.92; ball.vy *= 0.92;

        const steps = 8; const subVx = ball.vx / steps; const subVy = ball.vy / steps;
        for (let i = 0; i < steps; i++) {
            ball.x += subVx; checkCollisionX(); 
            ball.y += subVy; checkCollisionY();
            checkCornerCollision();
        }

        let pcx = Math.floor(ball.x / cellSize); let pcy = Math.floor(ball.y / cellSize);
        if (pcx === goal.x && pcy === goal.y) winGame();

        const offsetX = (COLS * cellSize) / 2; const offsetY = (ROWS * cellSize) / 2;
        ballMesh.position.x = ball.x - offsetX;
        ballMesh.position.z = ball.y - offsetY;
        ballMesh.position.y = ball.r;
        ballMesh.rotation.x -= ball.vy * 0.05; ballMesh.rotation.z -= ball.vx * 0.05;

        worldContainer.rotation.x = visualTiltY * 0.25;
        worldContainer.rotation.z = -visualTiltX * 0.25; 
    }

    function winGame() {
        if (!isPlaying) return; isPlaying = false; playWinSound();
        const duration = ((Date.now() - startTime) / 1000).toFixed(2);
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById('titleText').innerText = "MAZE COMPLETE!";
        document.getElementById('stats').innerText = `Time: ${duration}s`;
        document.getElementById('startBtn').innerText = "NEXT LEVEL";
        setTimeout(() => { document.getElementById('overlay').style.opacity = '1'; }, 10);
    }

    // --- COLLISION LOGIC (PLANAR) ---
    const physMargin = 0.25;

    function checkCollisionX() {
        if (ball.x - ball.r < 0) { ball.x = ball.r; bounceX(); }
        if (ball.x + ball.r > COLS * cellSize) { ball.x = COLS * cellSize - ball.r; bounceX(); }
        let cx = Math.floor(ball.x / cellSize), cy = Math.floor(ball.y / cellSize);
        cx = Math.max(0, Math.min(COLS-1, cx)); cy = Math.max(0, Math.min(ROWS-1, cy));
        let cell = maze[cy][cx], localX = ball.x % cellSize;
        if (cell.right && localX + ball.r + physMargin > cellSize) { bounceX(); ball.x = (cx + 1) * cellSize - ball.r - physMargin; }
        if (cell.left && localX - ball.r - physMargin < 0) { bounceX(); ball.x = cx * cellSize + ball.r + physMargin; }
    }
    function bounceX() { if(Math.abs(ball.vx) > 1.5) playBump(); ball.vx *= -0.3; }

    function checkCollisionY() {
        if (ball.y - ball.r < 0) { ball.y = ball.r; bounceY(); }
        if (ball.y + ball.r > ROWS * cellSize) { ball.y = ROWS * cellSize - ball.r; bounceY(); }
        let cx = Math.floor(ball.x / cellSize), cy = Math.floor(ball.y / cellSize);
        cx = Math.max(0, Math.min(COLS-1, cx)); cy = Math.max(0, Math.min(ROWS-1, cy));
        let cell = maze[cy][cx], localY = ball.y % cellSize;
        if (cell.bottom && localY + ball.r + physMargin > cellSize) { bounceY(); ball.y = (cy + 1) * cellSize - ball.r - physMargin; }
        if (cell.top && localY - ball.r - physMargin < 0) { bounceY(); ball.y = cy * cellSize + ball.r + physMargin; }
    }
    function bounceY() { if(Math.abs(ball.vy) > 1.5) playBump(); ball.vy *= -0.3; }

    // --- COLLISION LOGIC (CORNER GHOST FIX) ---
    function checkCornerCollision() {
        let ix = Math.round(ball.x / cellSize);
        let iy = Math.round(ball.y / cellSize);
        let px = ix * cellSize;
        let py = iy * cellSize;
        
        let dx = ball.x - px;
        let dy = ball.y - py;
        let distSq = dx*dx + dy*dy;
        let pillarR = wallThicknessVal * 0.5;
        let minDist = ball.r + pillarR;
        
        if (distSq < minDist * minDist) {
            // "Ghost Wall" Fix:
            // Calculate which wall segments exist at this intersection
            let segUp = (iy > 0 && ix > 0) ? maze[iy-1][ix-1].right : false;
            let segDown = (iy < ROWS && ix > 0) ? maze[iy][ix-1].right : false;
            let segLeft = (iy > 0 && ix > 0) ? maze[iy-1][ix-1].bottom : false;
            let segRight = (iy > 0 && ix < COLS) ? maze[iy-1][ix].bottom : false;

            // SMOOTHNESS CHECK:
            // If the wall is continuous vertically, and we are hitting the face (not the tip), SKIP.
            if (segUp && segDown && Math.abs(dx) > Math.abs(dy)) return;
            // If the wall is continuous horizontally, and we are hitting the face, SKIP.
            if (segLeft && segRight && Math.abs(dy) > Math.abs(dx)) return;

            // If we are here, we are hitting an actual exposed corner tip.
            if (segUp || segDown || segLeft || segRight) {
                let dist = Math.sqrt(distSq);
                if (dist < 0.001) { dx = 1; dy = 0; dist = 1; }
                let overlap = minDist - dist;
                let nx = dx / dist; let ny = dy / dist;
                ball.x += nx * overlap;
                ball.y += ny * overlap;
                let dot = ball.vx * nx + ball.vy * ny;
                if (dot < 0) {
                    ball.vx -= 2 * dot * nx; ball.vy -= 2 * dot * ny;
                    ball.vx *= 0.5; ball.vy *= 0.5;
                    if (Math.abs(dot) > 1.0) playBump();
                }
            }
        }
    }

    // --- AUDIO ---
    function playBump() {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        if (Date.now() - lastBumpTime < 200) return; lastBumpTime = Date.now();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine'; osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.8, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(now + 0.15);
    }

    function playWinSound() {
        if (!audioCtx) return; const now = audioCtx.currentTime;
        [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.type = 'sine'; osc.frequency.setValueAtTime(freq, now + (i * 0.1));
            gain.gain.setValueAtTime(0, now + (i * 0.1));
            gain.gain.linearRampToValueAtTime(0.2, now + (i * 0.1) + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, now + (i * 0.1) + 0.4);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(now + (i * 0.1)); osc.stop(now + (i * 0.1) + 0.5);
        });
    }

    function loop() {
        if (!isPlaying) return;
        update(); renderer.render(scene, camera);
        requestAnimationFrame(loop);
    }
</script>
</body>
</html>