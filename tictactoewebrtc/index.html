<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebRTC Tic‑Tac‑Toe — 8‑Bit Hacker</title>
  <style>
    :root {
      --bg: #000;            /* black */
      --panel: #03120b;      /* deep green */
      --panel-2: #051d12;    
      --grid: #041a10;
      --text: #c4ffda;       /* pale neon */
      --muted: #69d19e;
      --accent: #11ff88;     /* neon */
      --warn: #ffe175;
      --err: #ff8a8a;
      --scanline: rgba(17,255,136,0.05);
      --border: 1px solid rgba(17,255,136,0.28);
      --shadow: 0 18px 42px rgba(0, 0, 0, 0.6);
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 700px at 30% -10%, #04130a 0%, var(--bg) 55%);
      color: var(--text);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      letter-spacing: .3px;
      display: grid; place-items: start center; padding: 16px;
      image-rendering: pixelated; /* hint */
    }
    /* CRT scanlines + slight flicker */
    body:before{content:"";position:fixed;inset:0;background: repeating-linear-gradient(0deg, transparent 0 2px, var(--scanline) 2px 3px);pointer-events:none;mix-blend-mode:overlay;animation: flicker 6s steps(60,end) infinite;}
    @keyframes flicker { 0%,100%{opacity:.85} 50%{opacity:.92} }

    .app { width: 100%; max-width: 1040px; display: grid; gap: 16px; }

    .card { background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
            border: var(--border); padding: 14px; box-shadow: var(--shadow); }
    .card h2 { margin: 0 0 10px; font-weight: 900; text-transform: uppercase; font-size: 18px; color: var(--accent); text-shadow: 0 0 0 currentColor, 0 2px 0 currentColor, 2px 0 0 currentColor, 2px 2px 0 currentColor; }
    .muted { color: var(--muted); opacity: .95; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 0 0 currentColor, 0 1px 0 currentColor, 1px 0 0 currentColor, 1px 1px 0 currentColor; }

    .grid { display: grid; gap: 16px; grid-template-columns: 1.1fr 1fr; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }

    .boardWrap { position: relative; }
    .board { aspect-ratio: 1/1; display: grid; gap: 8px; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); background: var(--grid); padding: 8px; }
    .cell { display: grid; place-items: center; font-size: clamp(40px, 10vw, 72px); font-weight: 900; cursor: pointer; user-select: none; color: var(--text); background: #031e11; border: var(--border); transition: transform .06s ease, background .2s ease, box-shadow .2s ease, filter .2s ease; box-shadow: inset 0 0 0 1px rgba(0,0,0,.7); text-shadow: 0 0 0 currentColor, 0 2px 0 currentColor, 2px 0 0 currentColor, 2px 2px 0 currentColor; }
    .cell:hover { transform: translateY(-1px); box-shadow: 0 20px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(0,0,0,.7); filter: brightness(1.05); }
    .cell.disabled { pointer-events: none; opacity: .55; }
    .cell.win { animation: winPulse 600ms steps(6,end) infinite alternate; border-color: rgba(17,255,136,.8); }
    @keyframes winPulse { from{ box-shadow: 0 0 16px rgba(17,255,136,.4), inset 0 0 0 1px rgba(0,0,0,.7);} to{ box-shadow: 0 0 26px rgba(17,255,136,.75), inset 0 0 0 1px rgba(0,0,0,.7);} }

    .panel { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: space-between; margin-top: 8px; }
    .badge { padding: 6px 10px; border: var(--border); background: rgba(17,255,136,.08); color: var(--text); font-size: 10px; font-weight: 900; letter-spacing: 1px; text-transform: uppercase; text-shadow: 0 0 0 currentColor, 0 1px 0 currentColor, 1px 0 0 currentColor, 1px 1px 0 currentColor; }

    button { appearance: none; border: var(--border); padding: 10px 14px; font-weight: 900; color: #04130c; background: var(--accent); cursor: pointer; transition: transform .05s ease, filter .2s ease; box-shadow: none; text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 0 0 currentColor, 0 1px 0 currentColor, 1px 0 0 currentColor, 1px 1px 0 currentColor; }
    button:hover { transform: translateY(-1px); filter: brightness(1.06); }
    button.ghost { background: transparent; color: var(--text); }
    button.alt { background: #072116; color: var(--text); }
    button.warn { background: var(--warn); color: #331f05; border-color: rgba(255,225,117,.35); }

    textarea { width: 100%; min-height: 120px; padding: 10px 12px; background: #04150d; color: var(--text); border: var(--border); outline: none; text-transform: none; }
    textarea::placeholder { color: #69bf99; opacity: .8; }

    .steps { display: grid; gap: 10px; }
    .step { background: #031a10; border: var(--border); padding: 12px; }
    .step h3 { display: flex; align-items: center; gap: 8px; margin: 0 0 8px; font-size: 14px; color: var(--text); text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 0 0 currentColor, 0 1px 0 currentColor, 1px 0 0 currentColor, 1px 1px 0 currentColor; }
    .step .num { display:inline-grid; place-items:center; width: 22px; height: 22px; background: var(--accent); color:#05110c; font-weight: 900; font-size: 12px; }

    .tabs { display:flex; gap: 8px; margin-top: 8px; }
    .tab { flex: 1; text-align:center; padding: 10px; cursor:pointer; border: var(--border); background:#06130f; color: var(--text); font-weight:900; text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 0 0 currentColor, 0 1px 0 currentColor, 1px 0 0 currentColor, 1px 1px 0 currentColor; }
    .tab.active { background: rgba(17,255,136,.15); }
    .hidden { display:none !important; }

    .log { max-height: 220px; overflow: auto; background: #04160f; border: var(--border); padding: 8px 10px; font-size: 12px; }
    .log div { color: #bff7db; }
    .log .ok { color: #9cffd4; }
    .log .warn { color: var(--warn); }
    .log .err { color: var(--err); }
    .small { font-size: 11px; color: var(--mu80% { transform: translate(0,1px) }
      100% { transform: translate(0,0) }
    }
  </style>
</head>
<body>
  <div class="app">
    <section class="card">
      <h2>WebRTC Tic‑Tac‑Toe — 8‑Bit Hacker</h2>
      <div class="muted">Peer‑to‑peer via DataChannel. Manual signaling with JSON blobs <b>obscured with a fixed key</b> (not real security). No server.</div>

      <div id="status" class="panel">
        <span class="badge" id="roleBadge">offline</span>
        <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center">
          <span class="small">encryption: aes‑gcm / fixed key</span>
          <button id="newGameBtn" class="ghost">New session</button>
          <button id="resetBtn" class="alt">Reset board</button>
          <button id="syncBtn" class="ghost">Sync</button>
        </div>
      </div>

      <div class="grid" style="margin-top:10px">
        <div class="boardWrap">
          <div class="board" id="board"></div>
          <div id="overlay"><div class="overlayBox"><div id="overlayText" class="overlayText"></div></div></div>
          <div class="panel">
            <div class="small">You: <b id="myMark">–</b> • Turn: <b id="turn">–</b> • <span id="result"></span></div>
          </div>
        </div>
        <div>
          <div class="card" style="padding:12px">
            <div class="tabs">
              <div id="tabHost" class="tab active">Host</div>
              <div id="tabJoin" class="tab">Join</div>
            </div>

            <!-- HOST PANEL -->
            <div id="hostPanel" class="steps" style="margin-top:10px">
      ss="num">1</span> Create offer</h3>
                <button id="makeOffer">Gener
                <div class="panel">
                  <button id="copyOffer" class="ghost">Copy</button>
                  <button id="downloadOffer" class="ghost">Download offer.json</button>
                </div>
                <div class="small">Send the offer to your friend. The blob is lightly obscured with a shared, fixed key.</div>
              </div>
              <div class="step">
                <h3><span class="num">2</span> Paste answer</h3>
                <textarea id="answerIn" placeholder="Paste friend's Answer JSON"></textarea>
                <button id="applyAnswer" class="warn">Apply Answer</button>
              </div>
            </div>

            <!-- JOIN PANEL -->
            <div id="joinPanel" class="steps hidden" style="margin-top:10px">
              <div class="step">
                <h3><span class="num">1</span> Paste offer</h3>
                <textarea id="offerIn" placeholder="Paste host's Offer JSON"></textarea>
              </div>
              <div class="step">
                <h3><span class="num">2</span> Create answer</h3>
                <button id="acceptOffer">Generate Answer JSON</button>
                <textarea id="answerOut" placeholder="Answer JSON appears here" readonly></textarea>
                <div class="panel">
                  <button id="copyAnswer" class="ghost">Copy</button>
                  <button id="downloadAnswer" class="ghost">Download answer.json</button>
                </div>
                <div class="small">Send the answer back to the host. It will be obscured using the same fixed key.</div>
              </div>
            </div>

            <h3 class="small" style="margin-top:6px">Connection log</h3>
            <div id="log" class="log" aria-live="polite"></div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    // --- UI helpers ---
    const $ = (id) => document.getElementById(id);
    const logEl = $("log");
    function log(msg, cls="") { const d=document.createElement('div'); if(cls) d.className=cls; d.textContent=msg; logEl.appendChild(d); logEl.scrollTop = logEl.scrollHeight; }

    // Tabs
    const tabHost = $("tabHost"), tabJoin = $("tabJoin"), hostPanel = $("hostPanel"), joinPanel = $("joinPanel");
    tabHost.onclick = ()=>{ tabHost.classList.add('active'); tabJoin.classList.remove('active'); hostPanel.classList.remove('hidden'); joinPanel.classList.add('hidden'); };
    tabJoin.onclick = ()=>{ tabJoin.classList.add('active'); tabHost.classList.remove('active'); joinPanel.classList.remove('hidden'); hostPanel.classList.add('hidden'); };

    // --- Game state ---
    const boardEl = $("board");
    const turnEl = $("turn");
    const resultEl = $("result");
    const myMarkEl = $("myMark");
    const roleBadge = $("roleBadge");
    const overlay = $("overlay");
    const overlayText = $("overlayText");

    const state = {
      board: Array(9).fill(null),
      turn: 'X',
      myMark: null, // 'X' or 'O'
      connected: false,
    };

    function renderBoard() {
      boardEl.innerHTML = '';
      const win = winningLine(state.board);
      for (let i=0;i<9;i++) {
        const cell = document.createElement('button');
        cell.className = 'cell';
        cell.dataset.idx = i;
        cell.textContent = state.board[i] || '';
        if (win && win.includes(i)) cell.classList.add('win');
        if (state.board[i] || !state.connected || state.myMark !== state.turn || winner(state.board)) {
          cell.classList.add('disabled');
        }
        cell.addEventListener('click', () => onCellClick(i));
        boardEl.appendChild(cell);
      }
      turnEl.textContent = state.turn;
      myMarkEl.textContent = state.myMark || '–';

      const w = winner(state.board);
      if (w === 'draw') { resultEl.textContent = '— draw —'; showOverlay('DRAW'); }
      else if (w) { resultEl.textContent = `— ${w} wins —`; showOverlay(`${w} WINS`); }
      else { resultEl.textContent = ''; hideOverlay(); }
    }

    function resetBoard(localOnly=false) {
      state.board = Array(9).fill(null);
      state.turn = 'X';
      resultEl.textContent = '';
      hideOverlay();
      renderBoard();
      if (!localOnly) send({ type: 'sync', payload: snapshot() });
    }

    function snapshot() { return { board: state.board, turn: state.turn }; }

    function onCellClick(i) {
      if (state.board[i] || state.myMark !== state.turn) return;
      const w = winner(state.board); if (w) return;
      state.board[i] = state.myMark;
      state.turn = other(state.turn);
      renderBoard();
      send({ type: 'move', payload: i });
    }

    functioturn s === 'X' ? 'O' : 'X'; }

    function winner(b) {
      const lines = [ [0,1,2],[3,4,5],[6,7,8], [0,3,6],[1,4,7],[2,5,8], [0,4,8],[2,4,6] ];
      for (const [a,c,d] of lines) if (b[a] && b[a]===b[c] && b[a]===b[d]) return b[a];
      return b.every(Boolean) ? 'draw' : null;
    }
    function winningLine(b){
      const lines = [ [0,1,2],[3,4,5],[6,7,8], [0,3,6],[1,4,7],[2,5,8], [0,4,8],[2,4,6] ];
      for (const L of lines){ const [a,c,d]=L; if (b[a] && b[a]===b[c] && b[a]===b[d]) return L; }
      return null;
    }

    function showOverlay(text){ overlayText.textContent = text; overlay.classList.add('show'); }
    function hideOverlay(){ overlay.classList.remove('show'); }

    $("resetBtn").onclick = () => { resetBoard(); };
    $("newGameBtn").onclick = () => { teardown(); setup(); };
    $("syncBtn").onclick = () => send({ type: 'sync', payload: snapshot() });

    // --- WebRTC (no signaling server) ---
    let pc = null; let dc = null; let role = 'idle';
    const pcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    function setup() {
      teardown(true);
      pc = new RTCPeerConnection(pcConfig);
      pc.oniceconnectionstatechange = () => log(`ICE: ${pc.iceConnectionState}`);
      pc.onconnectionstatechange = () => log(`PC: ${pc.connectionState}`);
      pc.onicegatheringstatechange = () => log(`ICE gather: ${pc.iceGatheringState}`);
      pc.ondatachannel = (e) => {
        dc = e.channel; attachDataChannel();
        if (!state.myMark) state.myMark = 'O';
        renderBoard();
      };
      renderBoard();
    }

    function teardown(localOnly=false) {
      if (dc) { try{dc.close();}catch{} dc = null; }
      if (pc) { try{pc.close();}catch{} pc = null; }
      state.connected = false; role = 'idle'; roleBadge.textContent = 'offline';
      state.myMark = null; resetBoard(true);
    }

    function attachDataChannel() {
      dc.onopen = () => { state.connected = true; roleBadge.textContent = `connected (${role})`; log('data channel open', 'ok');
        if (!state.myMark) state.myMark = (role === 'host' ? 'X' : 'O');
        if (role === 'host') send({ type: 'sync', payload: snapshot() });
        renderBoard();
      };
      dc.onclose = () => { state.connected = false; roleBadge.textContent = 'disconnected'; log('data channel closed', 'warn'); };
      dc.onmessage = (e) => {
        try { const msg = JSON.parse(e.data); handleMsg(msg); } catch { log('bad message', 'err'); }
      };
    }

    function send(obj) { if (dc && dc.readyState === 'open') dc.send(JSON.stringify(obj)); }

    function handleMsg(msg) {
      switch (msg.type) {
        case 'move':
          applyMove(msg.payload, other(state.myMark));
          break;
        case 'sync':
          if (msg.payload && msg.payload.board && msg.payload.turn) {
            state.board = msg.payload.board.slice(0,9);
            state.turn = msg.payload.turn;
            renderBoard();
          }
          break;
        case 'reset':
          state.board = Array(9).fill(null); state.turn = 'X'; renderBoard();
          break;
      }
    }

    async function waitIceComplete() {
      if (!pc) return;
      if (pc.iceGatheringState === 'complete') return;
      await new Promise(res => {
        const check = () => {
          if (!pc) return res();
          if (pc.iceGatheringState === 'complete') {
            pc.removeEventListener('icegatheringstatechange', check);
            res();
          }
        };
        pc.addEventListener('icegatheringstatechange', check);
      });
    }

    function exportBlob(obj, pretty=true) { return JSON.stringify(obj, null, pretty ? 2 : 0); }

    function download(filename, text) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([text], { type: 'application/json' }));
      a.download = filename; a.click(); URL.revokeObjectURL(a.href);
    }

    // ---- Fixed-key encryption helpers (AES-GCM + PBKDF2) ----
    // This is intentionally weak/obscurity. Do not use for real security.
    const encHeader = 'enc-v1';
    const FIXED_SECRET = 'webrtc-ttt-fixed-key-v1';
    const FIXED_SALT_B64 = 'c2FsdC1maXhlZC12MQ=='; // "salt-fixed-v1" (base64)
    function strToBuf(str){ return new TextEncoder().encode(str); }
    function bufToStr(buf){ return new TextDecoder().decode(buf); }
    function b64ab(buf){ return btoa(String.fromCharCode(...new Uint8Array(buf))); }
    function abFromB64(b64){ const bin = atob(b64); const u8 = new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i); return u8.buffer; }

    async function deriveFixedKey(){
      const salt = new Uint8Array(abFromB64(FIXED_SALT_B64));
      const keyMaterial = await crypto.subtle.importKey('raw', strToBuf(FIXED_SECRET), 'PBKDF2', false, ['deriveKey']);
      return crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt','decrypt']
      );
    }
    async function encryptJSONFixed(obj){
      const plaintext = strToBuf(JSON.stringify(obj));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveFixedKey();
      const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, key, plaintext);
      return { [encHeader]: true, iv: b64ab(iv), data: b64ab(ct) };
    }
    async function decryptJSONFixed(blob){
      const iv = new Uint8Array(abFromB64(blob.iv));
      const key = await deriveFixedKey();
      const pt = await crypto.subtle.decrypt({ name:'AES-Gction hasEnc(b){ try{ const o=JSON.parse(b); return !!o && o[encHeader]; }catch{ return false; } }

    // --- Host flow ---
    $("makeOffer").onclick = async () => {
      setup(); role = 'host'; roleBadge.textContent = 'host'; tabHost.click();
      dc = pc.createDataChannel('ttt'); attachDataChannel();
      const offer = await pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
      await pc.setLocalDescription(offer);
      await waitIceComplete();
      const raw = { sdp: pc.localDescription.sdp, type: pc.localDescription.type };
      try { const enc = await encryptJSONFixed(raw); $("offerOut").value = exportBlob(enc); log('offer created (obscured)', 'ok'); }
      catch(e){ $("offerOut").value = exportBlob(raw); log('encryption failed — using plain offer', 'warn'); }
      state.myMark = 'X'; renderBoard();
    };

    $("downloadOffer").onclick = () => download('offer.json', $("offerOut").value || '{}');
    $("copyOffer").onclick = async () => { try { await navigator.clipboard.writeText($("offerOut").value); log('offer copied', 'ok'); } catch { log('clipboard failed', 'err'); } };

    $("applyAnswer").onclick = async () => {
      if (!pc) return log('create an offer first', 'warn');
      try {
        const txt = $("answerIn").value.trim();
        if (!txt) return log('paste an answer blob', 'warn');
        let payload;
        if (hasEnc(txt)) {
          payload = await decryptJSONFixed(JSON.parse(txt));
          log('answer decrypted', 'ok');
        } else { payload = JSON.parse(txt); }
        await pc.setRemoteDescription(new RTCSessionDescription(payload));
        log('answer applied — connecting…', 'ok');
      } catch (e) { log('invalid or undecryptable answer JSON', 'err'); }
    };

    // --- Join flow ---
    $("acceptOffer").onclick = async () => {
      setup(); role = 'guest'; roleBadge.textContent = 'guest'; tabJoin.click();
      try {
        const txt = $("offerIn").value.trim();
        if (!txt) return log('paste an offer blob', 'warn');
        let payload;
        if (hasEnc(txt)) {
          payload = await decryptJSONFixed(JSON.parse(txt));
          log('offer decrypted', 'ok');
        } else { payload = JSON.parse(txt); }
        await pc.setRemoteDescription(new RTCSessionDescription(payload));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await waitIceComplete();
        const raw = { sdp: pc.localDescription.sdp, type: pc.localDescription.type };
        try { const enc = await encryptJSONFixed(raw); $("answerOut").value = exportBlob(enc); log('answer ready (obscured) — send it back', 'ok'); }
        catch(e){ $("answerOut").value = exportBlob(raw); log('encryption failed — using plain answer', 'warn'); }
        state.myMark = 'O'; renderBoard(