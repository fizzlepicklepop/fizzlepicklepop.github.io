<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebRTC Tic‑Tac‑Toe — Hacker Mode</title>
  <style>
    :root {
      --bg: #050808;
      --panel: #081012;
      --panel-2: #0b1719;
      --grid: #0d1e1f;
      --text: #d8ffe5;
      --muted: #6dd1a3;
      --accent: #14ff9a;
      --accent-2: #13c08a;
      --warn: #ffe175;
      --err: #ff8a8a;
      --scanline: rgba(20, 255, 154, 0.04);
      --radius: 14px;
      --border: 1px solid rgba(20, 255, 154, 0.22);
      --shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 700px at 30% -10%, #071012 0%, var(--bg) 55%);
      color: var(--text);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      letter-spacing: .2px;
      display: grid; place-items: start center; padding: 20px;
    }

    /* subtle scanlines */
    body:before{content:"";position:fixed;inset:0;background: repeating-linear-gradient(0deg, transparent 0 2px, var(--scanline) 2px 3px);pointer-events:none;mix-blend-mode:overlay}

    .app { width: 100%; max-width: 980px; display: grid; gap: 18px; }

    .card { background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
            border: var(--border); border-radius: var(--radius); padding: 16px; box-shadow: var(--shadow); }
    .card h2 { margin: 0 0 10px; font-weight: 800; text-transform: uppercase; font-size: 18px; color: var(--accent); }
    .muted { color: var(--muted); opacity: .9; font-size: 12px; }

    .grid { display: grid; gap: 16px; grid-template-columns: 1fr 1fr; }
    @media (max-width: 880px) { .grid { grid-template-columns: 1fr; } }

    .board { aspect-ratio: 1/1; display: grid; gap: 8px; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); background: var(--grid); border-radius: 12px; padding: 8px; }
    .cell { display: grid; place-items: center; font-size: clamp(40px, 10vw, 64px); font-weight: 900; border-radius: 10px; cursor: pointer; user-select: none; color: var(--text); background: #071414; border: var(--border); transition: transform .06s ease, background .2s ease, box-shadow .2s ease; box-shadow: inset 0 0 0 1px rgba(0,0,0,.6); }
    .cell:hover { transform: translateY(-1px); box-shadow: 0 18px 26px rgba(0,0,0,.28), inset 0 0 0 1px rgba(0,0,0,.6); }
    .cell.disabled { pointer-events: none; opacity: .55; }

    .panel { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: space-between; margin-top: 8px; }
    .badge { padding: 6px 10px; border-radius: 999px; border: var(--border); background: rgba(20,255,154,.08); color: var(--text); font-size: 10px; font-weight: 800; letter-spacing: 1px; text-transform: uppercase; }

    button, .btn { appearance: none; border: var(--border); padding: 10px 14px; border-radius: 12px; font-weight: 800; color: #04130e; background: var(--accent); cursor: pointer; transition: transform .05s ease, filter .2s ease; box-shadow: 0 10px 30px rgba(20,255,154,.18); }
    button:hover { transform: translateY(-1px); filter: brightness(1.06); }
    button.ghost { background: transparent; color: var(--text); border-style: dashed; box-shadow: none; }
    button.alt { background: #0a1e17; color: var(--text); }
    button.warn { background: var(--warn); color: #331f05; border-color: rgba(255,225,117,.35); box-shadow: 0 10px 30px rgba(255,225,117,.15); }

    textarea { width: 100%; min-height: 120px; padding: 10px 12px; border-radius: 12px; background: #061411; color: var(--text); border: var(--border); outline: none; }
    textarea::placeholder { color: #6bbf9a; opacity: .8; }

    .steps { display: grid; gap: 10px; }
    .step { background: #07100f; border: var(--border); border-radius: 12px; padding: 12px; }
    .step h3 { display: flex; align-items: center; gap: 8px; margin: 0 0 8px; font-size: 14px; color: var(--text); }
    .step .num { display:inline-grid; place-items:center; width: 22px; height: 22px; border-radius: 50%; background: var(--accent); color:#05110c; font-weight: 900; font-size: 12px; }

    /* Tabs */
    .tabs { display:flex; gap: 8px; margin-top: 8px; }
    .tab { flex: 1; text-align:center; padding: 10px; border-radius: 10px; cursor:pointer; border: var(--border); background:#06130f; color: var(--text); font-weight:800; }
    .tab.active { background: rgba(20,255,154,.15); }
    .hidden { display:none !important; }

    /* Log */
    .log { max-height: 200px; overflow: auto; background: #06110e; border: var(--border); border-radius: 12px; padding: 8px 10px; font-size: 12px; }
    .log div { color: #bff7db; }
    .log .ok { color: #9cffd4; }
    .log .warn { color: var(--warn); }
    .log .err { color: var(--err); }

    .small { font-size: 11px; color: var(--muted) }
  </style>
</head>
<body>
  <div class="app">
    <section class="card">
      <h2>WebRTC Tic‑Tac‑Toe — Hacker Mode</h2>
      <div class="muted">Peer‑to‑peer via DataChannel. Manual signaling using copy‑paste JSON blobs. No server.</div>

      <div id="status" class="panel">
        <span class="badge" id="roleBadge">offline</span>
        <div>
          <button id="newGameBtn" class="ghost">New session</button>
          <button id="resetBtn" class="alt">Reset board</button>
          <button id="syncBtn" class="ghost">Sync</button>
        </div>
      </div>

      <div class="grid" style="margin-top:10px">
        <div>
          <div class="board" id="board"></div>
          <div class="panel">
            <div class="small">You: <b id="myMark">–</b> • Turn: <b id="turn">–</b> • <span id="result"></span></div>
          </div>
        </div>
        <div>
          <div class="card" style="padding:12px">
            <div class="tabs">
              <div id="tabHost" class="tab active">Host</div>
              <div id="tabJoin" class="tab">Join</div>
            </div>

            <!-- HOST PANEL -->
            <div id="hostPanel" class="steps" style="margin-top:10px">
              <div class="step">
                <h3><span class="num">1</span> Create offer</h3>
                <button id="makeOffer">Generate Offer JSON</button>
                <textarea id="offerOut" placeholder="Offer JSON appears here" readonly></textarea>
                <div class="panel">
                  <button id="copyOffer" class="ghost">Copy</button>
                  <button id="downloadOffer" class="ghost">Download offer.json</button>
                </div>
                <div class="small">Send the offer to your friend.</div>
              </div>
              <div class="step">
                <h3><span class="num">2</span> Paste answer</h3>
                <textarea id="answerIn" placeholder="Paste friend's Answer JSON"></textarea>
                <button id="applyAnswer" class="warn">Apply Answer</button>
              </div>
            </div>

            <!-- JOIN PANEL -->
            <div id="joinPanel" class="steps hidden" style="margin-top:10px">
              <div class="step">
                <h3><span class="num">1</span> Paste offer</h3>
                <textarea id="offerIn" placeholder="Paste host's Offer JSON"></textarea>
              </div>
              <div class="step">
                <h3><span class="num">2</span> Create answer</h3>
                <button id="acceptOffer">Generate Answer JSON</button>
                <textarea id="answerOut" placeholder="Answer JSON appears here" readonly></textarea>
                <div class="panel">
                  <button id="copyAnswer" class="ghost">Copy</button>
                  <button id="downloadAnswer" class="ghost">Download answer.json</button>
                </div>
                <div class="small">Send the answer back to the host.</div>
              </div>
            </div>

            <h3 class="small" style="margin-top:6px">Connection log</h3>
            <div id="log" class="log" aria-live="polite"></div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    // --- UI helpers ---
    const $ = (id) => document.getElementById(id);
    const logEl = $("log");
    function log(msg, cls="") { const d=document.createElement('div'); if(cls) d.className=cls; d.textContent=msg; logEl.appendChild(d); logEl.scrollTop = logEl.scrollHeight; }

    // Tabs
    const tabHost = $("tabHost"), tabJoin = $("tabJoin"), hostPanel = $("hostPanel"), joinPanel = $("joinPanel");
    tabHost.onclick = ()=>{ tabHost.classList.add('active'); tabJoin.classList.remove('active'); hostPanel.classList.remove('hidden'); joinPanel.classList.add('hidden'); };
    tabJoin.onclick = ()=>{ tabJoin.classList.add('active'); tabHost.classList.remove('active'); joinPanel.classList.remove('hidden'); hostPanel.classList.add('hidden'); };

    // --- Game state ---
    const boardEl = $("board");
    const turnEl = $("turn");
    const resultEl = $("result");
    const myMarkEl = $("myMark");
    const roleBadge = $("roleBadge");

    const state = {
      board: Array(9).fill(null),
      turn: 'X',
      myMark: null, // 'X' or 'O'
      connected: false,
    };

    function renderBoard() {
      boardEl.innerHTML = '';
      for (let i=0;i<9;i++) {
        const cell = document.createElement('button');
        cell.className = 'cell';
        cell.dataset.idx = i;
        cell.textContent = state.board[i] || '';
        if (state.board[i] || !state.connected || state.myMark !== state.turn || winner(state.board)) {
          cell.classList.add('disabled');
        }
        cell.addEventListener('click', () => onCellClick(i));
        boardEl.appendChild(cell);
      }
      turnEl.textContent = state.turn;
      myMarkEl.textContent = state.myMark || '–';

      const w = winner(state.board);
      if (w === 'draw') resultEl.textContent = '— draw —';
      else if (w) resultEl.textContent = `— ${w} wins —`;
      else resultEl.textContent = '';
    }

    function resetBoard(localOnly=false) {
      state.board = Array(9).fill(null);
      state.turn = 'X';
      resultEl.textContent = '';
      renderBoard();
      if (!localOnly) send({ type: 'sync', payload: snapshot() });
    }

    function snapshot() { return { board: state.board, turn: state.turn }; }

    function onCellClick(i) {
      if (state.board[i] || state.myMark !== state.turn) return;
      const w = winner(state.board); if (w) return;
      state.board[i] = state.myMark;
      state.turn = other(state.turn);
      renderBoard();
      send({ type: 'move', payload: i });
    }

    function applyMove(i, mark) {
      if (state.board[i] || winner(state.board)) return;
      state.board[i] = mark;
      state.turn = other(state.turn);
      renderBoard();
    }

    function other(s) { return s === 'X' ? 'O' : 'X'; }

    function winner(b) {
      const lines = [ [0,1,2],[3,4,5],[6,7,8], [0,3,6],[1,4,7],[2,5,8], [0,4,8],[2,4,6] ];
      for (const [a,c,d] of lines) if (b[a] && b[a]===b[c] && b[a]===b[d]) return b[a];
      return b.every(Boolean) ? 'draw' : null;
    }

    $("resetBtn").onclick = () => { resetBoard(); };
    $("newGameBtn").onclick = () => { teardown(); setup(); };
    $("syncBtn").onclick = () => send({ type: 'sync', payload: snapshot() });

    // --- WebRTC (no signaling server) ---
    let pc = null; let dc = null; let role = 'idle';

    const pcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    function setup() {
      teardown(true);
      pc = new RTCPeerConnection(pcConfig);
      pc.oniceconnectionstatechange = () => log(`ICE: ${pc.iceConnectionState}`);
      pc.onconnectionstatechange = () => log(`PC: ${pc.connectionState}`);
      pc.onicegatheringstatechange = () => log(`ICE gather: ${pc.iceGatheringState}`);
      pc.ondatachannel = (e) => {
        dc = e.channel; attachDataChannel();
        // Answerer becomes 'O' by default
        if (!state.myMark) state.myMark = 'O';
        renderBoard();
      };
      renderBoard();
    }

    function teardown(localOnly=false) {
      if (dc) { try{dc.close();}catch{} dc = null; }
      if (pc) { try{pc.close();}catch{} pc = null; }
      state.connected = false; role = 'idle'; roleBadge.textContent = 'offline';
      state.myMark = null; resetBoard(true);
    }

    function attachDataChannel() {
      dc.onopen = () => { state.connected = true; roleBadge.textContent = `connected (${role})`; log('data channel open', 'ok');
        if (!state.myMark) state.myMark = (role === 'host' ? 'X' : 'O');
        if (role === 'host') send({ type: 'sync', payload: snapshot() });
        renderBoard();
      };
      dc.onclose = () => { state.connected = false; roleBadge.textContent = 'disconnected'; log('data channel closed', 'warn'); };
      dc.onmessage = (e) => {
        try { const msg = JSON.parse(e.data); handleMsg(msg); } catch { log('bad message', 'err'); }
      };
    }

    function send(obj) { if (dc && dc.readyState === 'open') dc.send(JSON.stringify(obj)); }

    function handleMsg(msg) {
      switch (msg.type) {
        case 'move':
          applyMove(msg.payload, other(state.myMark));
          break;
        case 'sync':
          if (msg.payload && msg.payload.board && msg.payload.turn) {
            state.board = msg.payload.board.slice(0,9);
            state.turn = msg.payload.turn;
            renderBoard();
          }
          break;
        case 'reset':
          state.board = Array(9).fill(null); state.turn = 'X'; renderBoard();
          break;
      }
    }

    async function waitIceComplete() {
      if (!pc) return;
      if (pc.iceGatheringState === 'complete') return;
      await new Promise(res => {
        const check = () => {
          if (!pc) return res();
          if (pc.iceGatheringState === 'complete') {
            pc.removeEventListener('icegatheringstatechange', check);
            res();
          }
        };
        pc.addEventListener('icegatheringstatechange', check);
      });
    }

    function exportBlob(obj, pretty=true) { return JSON.stringify(obj, null, pretty ? 2 : 0); }

    function download(filename, text) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([text], { type: 'application/json' }));
      a.download = filename; a.click(); URL.revokeObjectURL(a.href);
    }

    // --- Host flow ---
    $("makeOffer").onclick = async () => {
      setup(); role = 'host'; roleBadge.textContent = 'host'; tabHost.click();
      dc = pc.createDataChannel('ttt'); attachDataChannel();
      const offer = await pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
      await pc.setLocalDescription(offer);
      await waitIceComplete();
      const blob = { sdp: pc.localDescription.sdp, type: pc.localDescription.type };
      $("offerOut").value = exportBlob(blob);
      log('offer created — share it', 'ok');
      state.myMark = 'X'; renderBoard();
    };

    $("downloadOffer").onclick = () => download('offer.json', $("offerOut").value || '{}');
    $("copyOffer").onclick = async () => { try { await navigator.clipboard.writeText($("offerOut").value); log('offer copied', 'ok'); } catch { log('clipboard failed', 'err'); } };

    $("applyAnswer").onclick = async () => {
      if (!pc) return log('create an offer first', 'warn');
      try {
        const ansText = $("answerIn").value.trim();
        if (!ansText) return log('paste an answer blob', 'warn');
        const ans = JSON.parse(ansText);
        await pc.setRemoteDescription(new RTCSessionDescription(ans));
        log('answer applied — connecting…', 'ok');
      } catch (e) { log('invalid answer JSON', 'err'); }
    };

    // --- Join flow ---
    $("acceptOffer").onclick = async () => {
      setup(); role = 'guest'; roleBadge.textContent = 'guest'; tabJoin.click();
      try {
        const offText = $("offerIn").value.trim();
        if (!offText) return log('paste an offer blob', 'warn');
        const off = JSON.parse(offText);
        await pc.setRemoteDescription(new RTCSessionDescription(off));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await waitIceComplete();
        const blob = { sdp: pc.localDescription.sdp, type: pc.localDescription.type };
        $("answerOut").value = exportBlob(blob);
        log('answer ready — send it back', 'ok');
        state.myMark = 'O'; renderBoard();
      } catch (e) { log('invalid offer JSON', 'err'); }
    };

    $("downloadAnswer").onclick = () => download('answer.json', $("answerOut").value || '{}');
    $("copyAnswer").onclick = async () => { try { await navigator.clipboard.writeText($("answerOut").value); log('answer copied', 'ok'); } catch { log('clipboard failed', 'err'); } };

    // Reset button sends a reset to peer if connected
    $("resetBtn").addEventListener('click', () => { send({ type: 'reset' }); });

    // Initialize UI
    setup();
  </script>
</body>
</html>
